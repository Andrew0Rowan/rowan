From e537ee452d73ae188cc732fea2efe3d0a3ca2e09 Mon Sep 17 00:00:00 2001
From: Nelson Liu <nelson.liu@mediatek.com>
Date: Sat, 10 Sep 2016 17:05:54 +0800
Subject: [PATCH 09/19] drm_prop: add interface for mtk drm module

configure interface are main for
1.client controll whether walk overlay flow or not
2.can operate drm like crtc_background/plane_rotate/alpha/colorkey
Test: test ok

Change-Id: I71098bba624e28a90442b0231ce754c0573b361a
Signed-off-by: Nelson Liu <nelson.liu@mediatek.com>
CR-Id: AUTO00000252
---
 Makefile.am                       |   52 +-
 clients/simple-configure-mtk.c    | 1727 +++++++++++++++++++++++++++++++++++++
 clients/simple-egl.c              |   34 +-
 configure.ac                      |    1 +
 protocol/weston-configure-mtk.xml |  130 +++
 src/compositor-drm.c              |  432 ++++++++--
 src/compositor.h                  |   72 ++
 src/main.c                        |    6 +
 src/weston-configure-mtk.c        |  413 +++++++++
 src/weston-configure-mtk.h        |   56 ++
 10 files changed, 2855 insertions(+), 68 deletions(-)
 create mode 100644 clients/simple-configure-mtk.c
 create mode 100644 protocol/weston-configure-mtk.xml
 create mode 100644 src/weston-configure-mtk.c
 create mode 100644 src/weston-configure-mtk.h

diff --git a/Makefile.am b/Makefile.am
index 98ef915..cb8e4aa 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -102,7 +102,9 @@ weston_SOURCES =					\
 	shared/zalloc.h					\
 	shared/platform.h				\
 	src/weston-egl-ext.h				\
-	src/notification-backend-mtk.c
+	src/notification-backend-mtk.c			\
+	src/weston-configure-mtk.c			\
+	src/weston-configure-mtk.h
 
 if SYSTEMD_NOTIFY_SUPPORT
 module_LTLIBRARIES += systemd-notify.la
@@ -136,7 +138,9 @@ nodist_weston_SOURCES =					\
 	protocol/linux-dmabuf-unstable-v1-protocol.c	\
 	protocol/linux-dmabuf-unstable-v1-server-protocol.h \
 	protocol/notification-mtk-protocol.c	\
-	protocol/notification-mtk-server-protocol.h
+	protocol/notification-mtk-server-protocol.h \
+	protocol/weston-configure-mtk-protocol.c \
+	protocol/weston-configure-mtk-server-protocol.h
 
 BUILT_SOURCES += $(nodist_weston_SOURCES)
 
@@ -301,7 +305,9 @@ drm_backend_la_SOURCES =			\
 	shared/helpers.h			\
 	shared/timespec-util.h			\
 	src/libbacklight.c			\
-	src/libbacklight.h
+	src/libbacklight.h			\
+	src/weston-configure-mtk.c		\
+	src/weston-configure-mtk.h
 
 if ENABLE_VAAPI_RECORDER
 drm_backend_la_SOURCES += src/vaapi-recorder.c src/vaapi-recorder.h
@@ -544,7 +550,9 @@ nodist_weston_simple_egl_SOURCES =		\
 	protocol/xdg-shell-unstable-v5-protocol.c		\
 	protocol/xdg-shell-unstable-v5-client-protocol.h	\
 	protocol/ivi-application-protocol.c		\
-	protocol/ivi-application-client-protocol.h
+	protocol/ivi-application-client-protocol.h	\
+	protocol/weston-configure-mtk-protocol.c	\
+	protocol/weston-configure-mtk-client-protocol.h
 weston_simple_egl_CFLAGS = $(AM_CFLAGS) $(SIMPLE_EGL_CLIENT_CFLAGS)
 weston_simple_egl_LDADD = $(SIMPLE_EGL_CLIENT_LIBS) -lm
 endif
@@ -579,6 +587,23 @@ weston_simple_dmabuf_v4l_LDADD = $(SIMPLE_DMABUF_V4L_CLIENT_LIBS) libshared.la
 BUILT_SOURCES += protocol/linux-dmabuf-unstable-v1-client-protocol.h
 endif
 
+if BUILD_SIMPLE_CONFIGURE_MTK_CLIENT
+demo_clients += weston-simple-configure-mtk
+weston_simple_configure_mtk_SOURCES = clients/simple-configure-mtk.c
+nodist_weston_simple_configure_mtk_SOURCES =               \
+        protocol/xdg-shell-unstable-v5-protocol.c               \
+        protocol/xdg-shell-unstable-v5-client-protocol.h        \
+        protocol/fullscreen-shell-unstable-v1-protocol.c        \
+        protocol/fullscreen-shell-unstable-v1-client-protocol.h \
+        protocol/linux-dmabuf-unstable-v1-protocol.c		\
+        protocol/linux-dmabuf-unstable-v1-client-protocol.h	\
+        protocol/weston-configure-mtk-protocol.c		\
+        protocol/weston-configure-mtk-client-protocol.h
+weston_simple_configure_mtk_CFLAGS = $(AM_CFLAGS) $(CLIENT_CFLAGS)
+weston_simple_configure_mtk_LDADD =  $(EGL_LIBS) libtoytoolkit.la
+BUILT_SOURCES += protocol/linux-dmabuf-unstable-v1-client-protocol.h
+endif
+
 noinst_LTLIBRARIES += libtoytoolkit.la
 
 libtoytoolkit_la_SOURCES =				\
@@ -827,7 +852,9 @@ BUILT_SOURCES +=					\
 	protocol/linux-dmabuf-unstable-v1-protocol.c		\
 	protocol/linux-dmabuf-unstable-v1-client-protocol.h		\
 	protocol/notification-mtk-protocol.c		\
-	protocol/notification-mtk-client-protocol.h
+	protocol/notification-mtk-client-protocol.h	\
+	protocol/weston-configure-mtk-protocol.c		\
+	protocol/weston-configure-mtk-client-protocol.h
 
 westondatadir = $(datadir)/weston
 dist_westondata_DATA =				\
@@ -842,7 +869,15 @@ dist_westondata_DATA =				\
 	data/icon_window.png			\
 	data/sign_close.png			\
 	data/sign_maximize.png			\
-	data/sign_minimize.png
+	data/sign_minimize.png			\
+	data/rawdata.rgb565			\
+	data/rawdata.xrgb			\
+	data/rawdata.argb			\
+	data/rawdata.yuyv			\
+	data/rawdata.nv12			\
+	data/rawdata.nv16			\
+	data/rawdata.yu12			\
+	data/rawdata.yv12
 
 if ENABLE_IVI_SHELL
 dist_westondata_DATA +=				\
@@ -1411,8 +1446,9 @@ EXTRA_DIST +=					\
 	protocol/weston-test.xml		\
 	protocol/scaler.xml			\
 	protocol/ivi-application.xml		\
-	protocol/ivi-hmi-controller.xml \
-	protocol/notification-mtk.xml
+	protocol/ivi-hmi-controller.xml 	\
+	protocol/notification-mtk.xml		\
+	protocol/weston-configure-mtk.xml
 
 #
 # manual test modules in tests subdirectory
diff --git a/clients/simple-configure-mtk.c b/clients/simple-configure-mtk.c
new file mode 100644
index 0000000..205cef2
--- /dev/null
+++ b/clients/simple-configure-mtk.c
@@ -0,0 +1,1727 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+#include <math.h>
+#include <assert.h>
+#include <sys/mman.h>
+#include <signal.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <linux/input.h>
+
+#include <wayland-client.h>
+#include <wayland-cursor.h>
+
+#include <drm_fourcc.h>
+#include <xf86drm.h>
+#include <xf86drmMode.h>
+
+#include <sys/types.h>
+#include <unistd.h>
+
+#include "ivi-application-client-protocol.h"
+#include "xdg-shell-unstable-v5-client-protocol.h"
+#include "linux-dmabuf-unstable-v1-client-protocol.h"
+#include "fullscreen-shell-unstable-v1-client-protocol.h"
+#include "weston-configure-mtk-client-protocol.h"
+
+#include <shared/platform.h>
+
+#define IVI_SURFACE_ID 9000
+#define MAX_IMAGE 16
+#define ALIGN(X,bit) ((X + bit-1) & (~(bit-1)))
+#define MAX_DMABUF_PLANES 4
+#define RES_NUM 4
+#define MAX_LEN 60
+
+struct window;
+struct seat;
+
+struct ddp_unit{
+	struct config_ddp_prop *ddp_prop;
+	uint32_t name;
+	struct wl_list link;
+};
+
+struct display {
+	struct wl_display *display;
+	struct wl_registry *registry;
+	struct wl_compositor *compositor;
+	struct xdg_shell *shell;
+	struct zwp_fullscreen_shell_v1 *fshell;
+	struct ivi_application *ivi_application;
+	struct wl_seat *seat;
+	struct wl_pointer *pointer;
+	struct wl_touch *touch;
+	struct wl_keyboard *keyboard;
+	struct wl_shm *shm;
+	struct zwp_linux_dmabuf_v1 *dmabuf;
+	struct wl_list output_list; /* struct output_unit::link */
+	struct wl_cursor_theme *cursor_theme;
+	struct wl_cursor *default_cursor;
+	struct wl_surface *cursor_surface;
+	struct window *window;
+	struct wl_list ddp_prox_list; /* struct ddp_unit::link */
+	struct config_switch *config_switch;
+};
+
+struct geometry {
+	int width, height;
+};
+
+struct buffer {
+	struct wl_buffer *buffer;
+	void *dma_map;
+	int busy;
+};
+
+struct app_plane_prop{
+	uint32_t alpha;
+	uint32_t colorkey;
+	uint32_t zpos;
+
+	uint32_t plane_id;
+	enum config_ddp_prop_plane_type type;
+	struct app_plane_prop *next;
+};
+
+struct app_crtc_prop {
+	int32_t background;
+	uint32_t crtc_id;
+	struct app_plane_prop *next;
+};
+
+/*one crtc match multi-plane*/
+struct app_ddp_prop {
+	int32_t crtc_background;
+	uint32_t crtc_id;
+
+	struct app_plane_prop *pl_prop;
+	/*ADD: any other resource can add here*/
+
+	struct app_ddp_prop *next;
+};
+
+enum ddp_op_type{
+	DDP_OP_NONE = 1 << 0,
+	DDP_OP_ALPHA = 1 << 1,
+	DDP_OP_COLORKEY = 1 << 2,
+	DDP_OP_ZPOS = 1 << 3,
+	DDP_OP_BACKGROUND = 1 << 4
+};
+
+struct file_arg{
+	char filename[MAX_LEN];
+	int width;
+	int height;
+	int format;
+};
+
+struct window {
+	struct display *display;
+	struct geometry geometry, window_size;
+
+	struct {
+		struct file_arg fProp;
+		struct buffer out_bufs[RES_NUM];
+	} image;
+	struct img_texture *tex;
+	uint32_t benchmark_time, frames;
+	struct wl_surface *surface;
+	struct xdg_surface *xdg_surface;
+	struct ivi_surface *ivi_surface;
+	struct wl_callback *callback;
+	int fullscreen, opaque, buffer_size, overlay, format;
+	enum wl_output_transform transform;
+	int drm_card_fd;
+	struct wl_array array;
+	struct config_switch_set *switch_set;
+	struct app_ddp_prop *ddp_prop;
+	struct {
+		uint32_t crtc_id;
+		int32_t background;
+		struct wl_array alpha_array;
+		struct wl_array colorkey_array;
+		struct wl_array zpos_array;
+		enum ddp_op_type type;
+	} input_ddp;
+};
+
+struct img_texture {
+	struct context *ctx;
+
+	/* input */
+	int width;
+	int height;
+	int drm_format;
+	int bpp;
+	int plane_nums;
+
+	int pitch[MAX_DMABUF_PLANES];
+	int offset[MAX_DMABUF_PLANES];
+	int fds[MAX_DMABUF_PLANES];
+	int handle[MAX_DMABUF_PLANES];
+
+	void *texbuf;
+	int size;
+};
+
+typedef enum _IMG_FORMAT_E {
+	IMG_FORMAT_RGB565 = 0,
+	IMG_FORMAT_XRGB8888,
+	IMG_FORMAT_ARGB8888,
+	IMG_FORMAT_YUYV,
+	IMG_FORMAT_NV12,
+	IMG_FORMAT_NV16,
+	IMG_FORMAT_YUV420,
+	IMG_FORMAT_YVU420,
+	IMG_FORMAT_LAST,
+} IMG_FORMAT_T;
+
+struct drm_fourcc_info {
+	unsigned int drm_format;
+	int plane_cnt;
+	int bpp;
+};
+
+static struct drm_fourcc_info fourcc_tbl[] = {
+	{DRM_FORMAT_RGB565, 1, 16},
+	{DRM_FORMAT_RGBA5551, 1, 16},
+	{DRM_FORMAT_RGBA4444, 1, 16},
+	{DRM_FORMAT_XRGB8888, 1, 32},
+	{DRM_FORMAT_XBGR8888, 1, 32},
+	{DRM_FORMAT_RGBX8888, 1, 32},
+	{DRM_FORMAT_BGRX8888, 1, 32},
+	{DRM_FORMAT_ARGB8888, 1, 32},
+	{DRM_FORMAT_ABGR8888, 1, 32},
+	{DRM_FORMAT_RGBA8888, 1, 32},
+	{DRM_FORMAT_BGRA8888, 1, 32},
+	{DRM_FORMAT_YUYV, 1, 16},
+	{DRM_FORMAT_VYUY, 1, 16},
+	{DRM_FORMAT_NV12, 2, 12},
+	{DRM_FORMAT_NV21, 2, 12},
+	{DRM_FORMAT_NV16, 2, 16},
+	{DRM_FORMAT_NV61, 2, 16},
+	{DRM_FORMAT_YUV420, 3, 12},
+	{DRM_FORMAT_YVU420, 3, 12},
+	{0, 0, 0},
+};
+
+static int running = 1;
+static int debug = 0;
+
+static int _format_transfer(int format, int *drm_format)
+{
+	int new_format;
+
+	if (!drm_format)
+		return -1;
+
+	switch (format) {
+		case IMG_FORMAT_RGB565:
+			new_format = DRM_FORMAT_RGB565;
+			break;
+		case IMG_FORMAT_XRGB8888:
+			new_format = DRM_FORMAT_XRGB8888;
+			break;
+		case IMG_FORMAT_ARGB8888:
+			new_format = DRM_FORMAT_ARGB8888;
+			break;
+		case IMG_FORMAT_YUYV:
+			new_format = DRM_FORMAT_YUYV;
+			break;
+		case IMG_FORMAT_NV12:
+			new_format = DRM_FORMAT_NV12;
+			break;
+		case IMG_FORMAT_NV16:
+			new_format = DRM_FORMAT_NV16;
+			break;
+		case IMG_FORMAT_YUV420:
+			new_format = DRM_FORMAT_YUV420;
+			break;
+		case IMG_FORMAT_YVU420:
+			new_format = DRM_FORMAT_YVU420;
+			break;
+		default:
+			return -2;
+	}
+	*drm_format = new_format;
+
+	return 0;
+}
+
+static struct drm_fourcc_info *
+get_drm_format_info(unsigned int format)
+{
+	int i;
+
+	for (i = 0; ; i++) {
+		if ( format == fourcc_tbl[i].drm_format){
+			return &fourcc_tbl[i];
+		}
+		if ( fourcc_tbl[i].drm_format == 0)
+			break;
+	}
+	return NULL;
+}
+
+static char *
+_get_tex_resource(int drifd, struct img_texture *tex)
+{
+    void *map = NULL;
+    struct drm_mode_create_dumb create_arg;
+    struct drm_mode_map_dumb map_arg;
+    struct drm_prime_handle prime_arg;
+    struct drm_fourcc_info *format_info;
+    int i, ret;
+    unsigned int alloc_size;
+
+    memset(&create_arg, 0, sizeof(create_arg));
+    memset(&map_arg, 0, sizeof(map_arg));
+    memset(&prime_arg, 0, sizeof(prime_arg));
+
+	for(i = 0; i < MAX_DMABUF_PLANES; i ++ )
+	    tex->fds[i] = -1;
+
+	format_info = get_drm_format_info(tex->drm_format);
+	if (format_info == NULL)
+		return NULL;
+
+	tex->bpp = format_info->bpp;
+	if (format_info->plane_cnt == 3) {
+		if (format_info->bpp == 12) {
+			tex->pitch[0] = ALIGN(tex->width, 16);
+			tex->pitch[1] = tex->pitch[0] / 2;
+			tex->pitch[2] = tex->pitch[0] / 2;
+			tex->offset[0] = 0;
+			tex->offset[1] = tex->pitch[0] * tex->height;
+			tex->offset[2] = tex->offset[1] + tex->pitch[1] * tex->height / 2;
+			alloc_size = tex->offset[2] + tex->pitch[2] * tex->height / 2;
+		} else {
+			fprintf(stderr,"debug: please add new format 0x%x\n", tex->drm_format);
+			return NULL;
+		}
+	} else if (format_info->plane_cnt == 2) {
+		tex->pitch[0] = ALIGN(tex->width, 16);
+		tex->offset[0] = 0;
+		if (format_info->bpp == 16) {
+			tex->pitch[1] = tex->pitch[0];
+			tex->offset[1] = tex->pitch[0] * tex->height;
+			alloc_size = tex->offset[1] + tex->pitch[1] * tex->height;
+			fprintf(stderr,"debug:  %s %d alloc_size = %d o/p [%d %d]\n",
+				__FUNCTION__, __LINE__, alloc_size, tex->offset[1], tex->pitch[1]);
+		}
+		else if (format_info->bpp == 12) {
+			tex->pitch[1] = tex->pitch[0] / 2;
+			tex->offset[1] = tex->pitch[0] * tex->height;
+			alloc_size = tex->offset[1] + tex->pitch[1] * tex->height;
+		} else {
+			fprintf(stderr,"debug: please add new format 0x%x\n", tex->drm_format);
+			return NULL;
+		}
+	} else {
+		tex->pitch[0] = ALIGN(tex->width * tex->bpp / 8, 16);
+		tex->offset[0] = 0;
+		alloc_size = tex->pitch[0] * tex->height;
+	}
+
+	create_arg.bpp = 8;
+	create_arg.width = alloc_size;
+	create_arg.height = 1;
+
+    ret = drmIoctl(drifd, DRM_IOCTL_MODE_CREATE_DUMB, &create_arg);
+    if (ret) {
+            fprintf(stderr,"error: drmIoctl %d DRM_IOCTL_MODE_CREATE_DUMB fail %d\n", drifd, ret);
+            return NULL;
+    }
+
+    map_arg.handle = create_arg.handle;
+
+    ret = drmIoctl(drifd, DRM_IOCTL_MODE_MAP_DUMB, &map_arg);
+    if (ret) {
+            fprintf(stderr,"error: drmIoctl DRM_IOCTL_MODE_MAP_DUMB fail %d\n", ret);
+            return NULL;
+    }
+
+    map = mmap(0, create_arg.size, PROT_WRITE|PROT_READ , MAP_SHARED, drifd, map_arg.offset);
+    if (map == MAP_FAILED) {
+            fprintf(stderr,"error: mmap fail : 0x%x\n", (unsigned int)map);
+            return NULL;
+    }
+
+    prime_arg.handle = create_arg.handle;
+    prime_arg.flags = DRM_CLOEXEC;
+    ret = drmIoctl(drifd, DRM_IOCTL_PRIME_HANDLE_TO_FD, &prime_arg);
+    if (ret || prime_arg.fd == -1) {
+            fprintf(stderr,"error: drmIoctl DRM_IOCTL_PRIME_HANDLE_TO_FD fail %d fd=%d\n",ret,prime_arg.fd);
+            return NULL;
+    }
+
+	for (i = 0; i < format_info->plane_cnt; i++) {
+		tex->fds[i] = prime_arg.fd;
+		tex->handle[i] = create_arg.handle;
+	}
+	tex->plane_nums = format_info->plane_cnt;
+	tex->texbuf = map;
+	tex->size = create_arg.size;
+
+	return map;
+}
+
+static int
+init_img_texture(struct window *window)
+{
+	int ret;
+	struct img_texture *tex;
+	tex = malloc(sizeof *tex);
+	if (tex == NULL)
+		return -1;
+
+	ret = _format_transfer(window->image.fProp.format, &(tex->drm_format));
+	if (ret < 0)
+		return -1;
+
+	tex->width = window->image.fProp.width;
+	tex->height= window->image.fProp.height;
+
+	window->tex = tex;
+	return 0;
+}
+
+static void
+buffer_release(void *data, struct wl_buffer *buffer)
+{
+	struct buffer *mybuf = data;
+
+	mybuf->busy = 0;
+}
+
+static const struct wl_buffer_listener buffer_listener = {
+	buffer_release
+};
+
+static void
+create_succeeded(void *data,
+		 struct zwp_linux_buffer_params_v1 *params,
+		 struct wl_buffer *new_buffer)
+{
+	struct buffer *buffer = data;
+
+	buffer->buffer = new_buffer;
+	wl_buffer_add_listener(buffer->buffer, &buffer_listener, buffer);
+
+	zwp_linux_buffer_params_v1_destroy(params);
+}
+
+static void
+create_failed(void *data, struct zwp_linux_buffer_params_v1 *params)
+{
+	struct buffer *buffer = data;
+
+	buffer->buffer = NULL;
+
+	zwp_linux_buffer_params_v1_destroy(params);
+
+	running = false;
+
+	fprintf(stderr, "Error: zwp_linux_buffer_params.create failed.\n");
+}
+
+static const struct zwp_linux_buffer_params_v1_listener params_listener = {
+	create_succeeded,
+	create_failed
+};
+
+static int
+create_dmabuf_buffer(struct display *display, struct buffer *buffer)
+{
+	struct zwp_linux_buffer_params_v1 *params;
+	struct img_texture *cbtex = display->window->tex;
+	uint64_t modifier;
+	uint32_t flags;
+	int i;
+	/* output */
+	buffer->dma_map = _get_tex_resource(display->window->drm_card_fd, cbtex);
+
+	if (buffer->dma_map == NULL) {
+		fprintf(stderr, "error: _get_tex_resource failed\n");
+		return -1;
+	}
+
+	modifier = 0;
+	flags = ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_Y_INVERT;
+
+	params = zwp_linux_dmabuf_v1_create_params(display->dmabuf);
+
+	for(i = 0; i < cbtex->plane_nums; i ++)
+	{
+		zwp_linux_buffer_params_v1_add(params,
+				cbtex->fds[i],
+				i, /* plane_idx */
+				cbtex->offset[i],/* offset */
+				cbtex->pitch[i],
+				modifier >> 32,
+				modifier & 0xffffffff);
+	}
+	zwp_linux_buffer_params_v1_add_listener(params, &params_listener, buffer);
+	zwp_linux_buffer_params_v1_create(params,
+				    cbtex->width,
+				    cbtex->height,
+				    cbtex->drm_format,
+				    flags);
+
+	/* params is destroyed by the event handlers */
+	wl_display_roundtrip(display->display);
+	if (buffer->buffer == NULL) {
+		return -1;
+	}
+
+	return 0;
+}
+
+static int
+_load_file(void *buf, int len, const char *file_name)
+{
+    int ret, nread = 0;
+
+    FILE *fp = fopen(file_name, "rb");
+    if (!fp)
+    {
+        fprintf(stderr,"debug: file %s open failed\n", file_name);
+        return -1;
+    }
+
+    while (nread < len) {
+        ret = fread(buf + nread, 1, len - nread, fp);
+        if (!ret)
+                break;
+        nread += ret;
+    }
+
+    fclose(fp);
+    return 0;
+}
+
+static int
+_write_file(void *buf, int len, const char *file_name)
+{
+    int ret, nwrite = 0;
+
+    FILE *fp = fopen(file_name, "wb");
+    if (!fp)
+    {
+        fprintf(stderr,"debug: file %s open failed\n", file_name);
+        return -1;
+    }
+
+    while (nwrite < len) {
+        ret = fwrite(buf + nwrite, 1, len - nwrite, fp);
+        if (!ret)
+                break;
+        nwrite += ret;
+    }
+
+    fclose(fp);
+    return 0;
+}
+
+static int
+_kms_device_fd(void)
+{
+    int i;
+    bool has_conn = false;
+    for (i = 0; i < 8; ++i) {
+        char path[99];
+        sprintf(path, "/dev/dri/card%d", i);
+        fprintf(stderr, "debug: trying %s\n", path);
+        int fd = open(path, O_RDWR | O_CLOEXEC);
+        if (fd >= 0) {
+            drmModeResPtr mr = drmModeGetResources(fd);
+            if (mr) {
+                has_conn = mr->count_connectors > 0;
+                drmModeFreeResources(mr);
+            }
+            if (has_conn) {
+                fprintf(stderr, "debug: using %s\n", path);
+                return fd;
+            }
+            close(fd);
+        }
+    }
+    return -1;
+}
+
+static void debug_drm_ddp_prop(struct window *window)
+{
+	struct app_ddp_prop *ddp;
+	struct app_plane_prop *ppos;
+
+	ddp = window->ddp_prop;
+	while(ddp != NULL) {
+		ppos = ddp->pl_prop;
+		while (ppos != NULL) {
+			fprintf(stderr,"debug: drm plane properties:plane_id/"
+					"alpha/colorkey/zpos/type[%u %d %d %d %d]\n",
+					ppos->plane_id, ppos->alpha, ppos->colorkey,
+					ppos->zpos, ppos->type);
+			ppos = ppos->next;
+		}
+
+		fprintf(stderr,"debug: drm crtc properties:crtc_id/background"
+						"[%u %d]\n",ddp->crtc_id, ddp->crtc_background);
+		ddp = ddp->next;
+	}
+	return;
+}
+
+static struct app_plane_prop *app_plane_create(void)
+{
+	struct app_plane_prop *dplane;
+	dplane = (struct app_plane_prop *)malloc(sizeof(*dplane));
+	if (dplane == NULL) {
+		fprintf(stderr,"error: fail to malloc memory to dplane\n");
+		return NULL;
+	}
+
+	dplane->alpha = -1;
+	dplane->colorkey = -1;
+	dplane->zpos = -1;
+
+	dplane->plane_id = 0;
+	dplane->next = NULL;
+
+	return dplane;
+}
+
+static struct app_ddp_prop *app_ddp_create(void)
+{
+	struct app_ddp_prop *ddp;
+	ddp = (struct app_ddp_prop *)malloc(sizeof(*ddp));
+	if (ddp == NULL) {
+		fprintf(stderr,"error: fail to malloc"
+						"memory to app_ddp_prop\n");
+		return NULL;
+	}
+
+	ddp->crtc_background = -1;
+	ddp->crtc_id = 0;
+	ddp->pl_prop = NULL;
+	ddp->next = NULL;
+
+	return ddp;
+}
+
+static struct app_ddp_prop *
+find_ddp_header(struct app_ddp_prop *ddp, uint32_t crtc_id)
+{
+	struct app_ddp_prop *dtmp = ddp;
+
+	while (ddp != NULL) {
+		/*find header correctly according crtc_id*/
+		if (ddp->crtc_id != crtc_id) {
+			if (ddp->next != NULL) {
+				ddp = ddp->next;
+				continue;
+			} else {
+				/*if not exist, create it.*/
+				dtmp = app_ddp_create();
+				if (!dtmp)
+					return NULL;
+				ddp->next = dtmp;
+				return dtmp;
+			}
+		} else
+			return ddp;
+	}
+	/*the entry is invalid, so creat it.*/
+	dtmp = app_ddp_create();
+	if (!dtmp)
+		return NULL;
+	return dtmp;
+}
+
+static void handle_drm_send_plane_prop(void *data, struct config_ddp_prop *config_ddp_prop,
+							uint32_t crtc_id, uint32_t alpha, uint32_t colorkey,
+							uint32_t zpos, uint32_t plane_id, int32_t type)
+{
+	struct window *window = data;
+	struct app_plane_prop *new_plane, *pos;
+	struct app_ddp_prop *ddp, *ddp_pos;
+
+	ddp = window->ddp_prop;
+	/*find element pointer from linked-list*/
+	ddp_pos = find_ddp_header(ddp, crtc_id);
+	if (ddp_pos == NULL)
+		return;
+	/*maybe window->ddp_prop is NULL*/
+	if (!window->ddp_prop)
+		window->ddp_prop = ddp_pos;
+
+	pos = ddp_pos->pl_prop;
+	if (pos == NULL) {
+		/*first time, header is not exist*/
+		pos = app_plane_create();
+		if (!pos)
+			return;
+		ddp_pos->pl_prop = pos;
+		pos->alpha = alpha;
+		pos->colorkey = colorkey;
+		pos->zpos = zpos;
+		pos->plane_id = plane_id;
+		pos->type = type;
+	} else {
+		/*if plane_id is not match, then create;
+			plane_id matched, change properties directly.*/
+		while (pos->plane_id != plane_id) {
+			if (pos->next == NULL) {
+				new_plane = app_plane_create();
+				if (!new_plane)
+					return;
+				new_plane->plane_id = plane_id;
+				pos->next = new_plane;
+				pos = pos->next;
+				break;
+			}
+			pos = pos->next;
+		}
+		pos->alpha = alpha;
+		pos->colorkey = colorkey;
+		pos->zpos = zpos;
+		pos->type = type;
+	}
+
+	debug_drm_ddp_prop(window);
+
+	return;
+}
+
+static void handle_drm_send_crtc_prop(void *data,
+	struct config_ddp_prop *config_ddp_prop, int32_t background, uint32_t crtc_id)
+{
+	struct window *window = data;
+	struct app_ddp_prop *ddp, *ddp_pos;
+
+	ddp = window->ddp_prop;
+	/*find element pointer from linked-list*/
+	ddp_pos = find_ddp_header(ddp, crtc_id);
+	if (ddp_pos == NULL)
+		return;
+	/*maybe window->ddp_prop is NULL*/
+	if (!window->ddp_prop)
+		window->ddp_prop = ddp_pos;
+
+	ddp_pos->crtc_background = background;
+	ddp_pos->crtc_id = crtc_id;
+
+	debug_drm_ddp_prop(window);
+	return;
+
+}
+
+
+static const struct config_ddp_prop_listener config_ddp_prop_listener = {
+	handle_drm_send_plane_prop,
+	handle_drm_send_crtc_prop,
+};
+
+static void
+handle_surface_configure(void *data, struct xdg_surface *surface,
+			 int32_t width, int32_t height,
+			 struct wl_array *states, uint32_t serial)
+{
+	struct window *window = data;
+	uint32_t *p;
+
+	window->fullscreen = 0;
+	wl_array_for_each(p, states) {
+		uint32_t state = *p;
+		switch (state) {
+		case XDG_SURFACE_STATE_FULLSCREEN:
+			window->fullscreen = 1;
+			break;
+		}
+	}
+
+	if (width > 0 && height > 0) {
+		if (!window->fullscreen) {
+			window->window_size.width = width;
+			window->window_size.height = height;
+		}
+		window->geometry.width = width;
+		window->geometry.height = height;
+	} else if (!window->fullscreen) {
+		window->geometry = window->window_size;
+	}
+
+	xdg_surface_ack_configure(surface, serial);
+}
+
+static void
+handle_surface_delete(void *data, struct xdg_surface *xdg_surface)
+{
+	running = 0;
+}
+
+static const struct xdg_surface_listener xdg_surface_listener = {
+	handle_surface_configure,
+	handle_surface_delete,
+};
+
+static void
+handle_ivi_surface_configure(void *data, struct ivi_surface *ivi_surface,
+                             int32_t width, int32_t height)
+{
+
+}
+
+static const struct ivi_surface_listener ivi_surface_listener = {
+	handle_ivi_surface_configure,
+};
+
+static struct buffer *
+window_next_buffer(struct window *window)
+{
+	struct buffer *buffer = NULL;
+	int i, ret = 0;
+
+	for(i = 0; i < RES_NUM; i++) {
+		if (!window->image.out_bufs[i].busy) {
+			buffer = &window->image.out_bufs[i];
+			break;
+		}
+	}
+
+	if (!buffer)
+		return NULL;
+
+	if (!buffer->buffer) {
+		ret = create_dmabuf_buffer(window->display, buffer);
+		if (ret < 0)
+			return NULL;
+	}
+
+	return buffer;
+}
+
+static void
+create_surface(struct window *window)
+{
+	struct display *display = window->display;
+
+	window->surface = wl_compositor_create_surface(display->compositor);
+	display->cursor_surface =
+		wl_compositor_create_surface(display->compositor);
+
+	window->switch_set = config_switch_connect(display->config_switch, window->surface);
+
+	if (display->shell) {
+		window->xdg_surface =
+			xdg_shell_get_xdg_surface(display->shell,
+			                          window->surface);
+
+		assert(window->xdg_surface);
+
+		xdg_surface_add_listener(window->xdg_surface,
+		                         &xdg_surface_listener, window);
+
+		xdg_surface_set_title(window->xdg_surface, "simple-configure-mtk");
+	} else if (display->fshell) {
+		zwp_fullscreen_shell_v1_present_surface(display->fshell,
+		                                        window->surface,
+		                                        ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_DEFAULT,
+		                                        NULL);
+	} else if (display->ivi_application ) {
+		uint32_t id_ivisurf = IVI_SURFACE_ID + (uint32_t)getpid();
+		window->ivi_surface =
+			ivi_application_surface_create(display->ivi_application,
+						       id_ivisurf, window->surface);
+		if (window->ivi_surface == NULL) {
+			fprintf(stderr, "Failed to create ivi_client_surface\n");
+			abort();
+		}
+
+		ivi_surface_add_listener(window->ivi_surface,
+					 &ivi_surface_listener, window);
+
+	} else {
+		assert(0);
+	}
+
+}
+
+static void
+destroy_surface(struct window *window)
+{
+	if (window->xdg_surface)
+		xdg_surface_destroy(window->xdg_surface);
+	if (window->display->ivi_application)
+		ivi_surface_destroy(window->ivi_surface);
+	if (window->display->fshell)
+		zwp_fullscreen_shell_v1_release(window->display->fshell);
+	wl_surface_destroy(window->surface);
+
+	if (window->callback)
+		wl_callback_destroy(window->callback);
+
+	if (window->image.out_bufs[0].buffer)
+		wl_buffer_destroy(window->image.out_bufs[0].buffer);
+	if (window->image.out_bufs[1].buffer)
+		wl_buffer_destroy(window->image.out_bufs[1].buffer);
+	if (window->image.out_bufs[2].buffer)
+		wl_buffer_destroy(window->image.out_bufs[2].buffer);
+}
+
+static int
+config_set_ddp_props(struct window *window)
+{
+	struct app_ddp_prop *dpos, *dptmp;
+	struct app_plane_prop *ppos;
+	struct wl_list *ddp_prox_list = &(window->display->ddp_prox_list);
+	uint32_t crtc_id = window->input_ddp.crtc_id;
+	uint32_t flag = window->input_ddp.type;
+	struct ddp_unit *rddp, *rdtmp;
+	int64_t ret, *p;
+	uint64_t *p64;
+
+	/*find header where store ddp resource*/
+	dptmp = window->ddp_prop;
+	if (!dptmp) {
+		fprintf(stderr, "error: window->ddp_prop not initialize\n");
+		return -1;
+	}
+	/*if output is more than one, then you should choose
+	 *correct header according crtc_id */
+	dpos = find_ddp_header(dptmp, crtc_id);
+	if (dpos && (!dpos->crtc_id)) {
+		fprintf(stderr, "error: not found matched crtc\n");
+		free(dpos);
+		return -1;
+	} else if (!dpos) {
+		return -1;
+	} else {
+	/*check if plane_prop is valided*/
+		if (!dpos->pl_prop)
+			return -1;
+		ppos = dpos->pl_prop;
+	}
+	while (flag != DDP_OP_NONE) {
+		if ((flag & DDP_OP_ALPHA))
+		{
+			wl_array_for_each(p, &window->input_ddp.alpha_array) {
+				if (ppos) {
+					/*bit0~bit32: prop value; bit33~bit63: plane_id*/
+					p64 = wl_array_add(&window->array, sizeof(*p64));
+					*p64 = (uint64_t)(ppos->plane_id);
+					*p64 = (uint64_t)(*p64 << 33) | ((*p)&0x00000001ffffffff);
+					ppos = ppos->next;
+				}
+			}
+			wl_list_for_each_safe(rddp, rdtmp, ddp_prox_list, link)
+				config_ddp_prop_set_plane_alpha(rddp->ddp_prop, crtc_id, &window->array);
+
+			flag &= ~DDP_OP_ALPHA;
+			ret = 0;
+		} else if ((flag & DDP_OP_COLORKEY)) {
+			wl_array_for_each(p, &window->input_ddp.colorkey_array) {
+				if (ppos) {
+					/*bit0~bit32: prop value; bit33~bit63: plane_id*/
+					p64 = wl_array_add(&window->array, sizeof(*p64));
+					*p64 = (uint64_t)(ppos->plane_id);
+					*p64 = (uint64_t)(*p64 << 33) | ((*p)&0x00000001ffffffff);
+					ppos = ppos->next;
+				}
+			}
+			wl_list_for_each_safe(rddp, rdtmp, ddp_prox_list, link)
+				config_ddp_prop_set_plane_colorkey(rddp->ddp_prop, crtc_id, &window->array);
+
+			flag &= ~DDP_OP_COLORKEY;
+			ret = 0;
+
+		} else if ((flag & DDP_OP_ZPOS)) {
+			wl_array_for_each(p, &window->input_ddp.zpos_array) {
+				if (ppos) {
+					/*bit0~bit32: prop value; bit33~bit63: plane_id*/
+					p64 = wl_array_add(&window->array, sizeof(*p64));
+					*p64 = (uint64_t)(ppos->plane_id);
+					*p64 = (uint64_t)(*p64 << 33) | ((*p)&0x00000001ffffffff);
+					ppos = ppos->next;
+				}
+			}
+			wl_list_for_each_safe(rddp, rdtmp, ddp_prox_list, link)
+				config_ddp_prop_set_plane_zpos(rddp->ddp_prop, crtc_id, &window->array);
+
+			flag &= ~DDP_OP_ZPOS;
+			ret = 0;
+		} else if ((flag & DDP_OP_BACKGROUND)) {
+			fprintf(stderr, "error: crtc_id = %d background = 0x%x\n", crtc_id, window->input_ddp.background);
+			wl_list_for_each_safe(rddp, rdtmp, ddp_prox_list, link)
+				config_ddp_prop_set_crtc_background(rddp->ddp_prop, crtc_id, window->input_ddp.background);
+
+			flag &= ~DDP_OP_BACKGROUND;
+			ret = 0;
+		} else {
+			fprintf(stderr, "error: maybe ddp_op_type(%d) is not correct.\n", flag);
+			ret = -1;
+		}
+	}
+	return ret;
+}
+
+static const struct wl_callback_listener frame_listener;
+
+static void
+redraw(void *data, struct wl_callback *callback, uint32_t time)
+{
+	struct window *window = data;
+	struct buffer *buffer;
+	char filename[MAX_LEN] = {0};
+	static const uint32_t benchmark_interval = 5;
+	struct wl_region *region;
+	struct timeval tv;
+	int tmp;
+
+	buffer = window_next_buffer(window);
+	if (!buffer) {
+		fprintf(stderr,
+			!callback ? "error: Failed to create the first buffer.\n" :
+			"error: Both buffers busy at redraw(). Server bug?\n");
+		abort();
+
+		if (callback)
+			wl_callback_destroy(callback);
+
+		window->callback = wl_surface_frame(window->surface);
+		wl_callback_add_listener(window->callback, &frame_listener, window);
+		return;
+	}
+
+	gettimeofday(&tv, NULL);
+	time = tv.tv_sec * 1000 + tv.tv_usec / 1000;
+	if (window->frames == 0)
+		window->benchmark_time = time;
+	if (time - window->benchmark_time > (benchmark_interval * 1000)) {
+		printf("debug: %d frames in %d seconds: %f fps\n",
+		       window->frames,
+		       benchmark_interval,
+		       (float) window->frames / benchmark_interval);
+		window->benchmark_time = time;
+		window->frames = 0;
+	}
+
+	tmp = _load_file(buffer->dma_map, window->tex->size, window->image.fProp.filename);
+	if(tmp < 0) {
+		fprintf(stderr, "error: fail to _load_file\n");
+		return;
+	}
+
+	if((debug == 1) && (window->frames == 0))
+	{
+		snprintf(filename, 64, "/run/media/sda1/_dump_simple_configure_%d", time);
+		_write_file(buffer->dma_map, window->tex->size, filename);
+	}
+
+	if (window->opaque || window->fullscreen) {
+		region = wl_compositor_create_region(window->display->compositor);
+		wl_region_add(region, 0, 0,
+			      window->geometry.width,
+			      window->geometry.height);
+		wl_surface_set_opaque_region(window->surface, region);
+		wl_region_destroy(region);
+	} else {
+		wl_surface_set_opaque_region(window->surface, NULL);
+	}
+
+	wl_surface_attach(window->surface, buffer->buffer, 0, 0);
+	wl_surface_set_buffer_transform(window->surface,
+					window->transform);
+	wl_surface_damage(window->surface,
+			  0, 0, window->geometry.width, window->geometry.height);
+
+	if (callback)
+		wl_callback_destroy(callback);
+
+	window->callback = wl_surface_frame(window->surface);
+	wl_callback_add_listener(window->callback, &frame_listener, window);
+	wl_surface_commit(window->surface);
+	buffer->busy = 1;
+
+	window->frames++;
+}
+
+static const struct wl_callback_listener frame_listener = {
+	redraw
+};
+
+static void
+pointer_handle_enter(void *data, struct wl_pointer *pointer,
+		     uint32_t serial, struct wl_surface *surface,
+		     wl_fixed_t sx, wl_fixed_t sy)
+{
+	struct display *display = data;
+	struct wl_buffer *buffer;
+	struct wl_cursor *cursor = display->default_cursor;
+	struct wl_cursor_image *image;
+
+	if (display->window->fullscreen)
+		wl_pointer_set_cursor(pointer, serial, NULL, 0, 0);
+	else if (cursor) {
+		image = display->default_cursor->images[0];
+		buffer = wl_cursor_image_get_buffer(image);
+		if (!buffer)
+			return;
+		wl_pointer_set_cursor(pointer, serial,
+				      display->cursor_surface,
+				      image->hotspot_x,
+				      image->hotspot_y);
+		wl_surface_attach(display->cursor_surface, buffer, 0, 0);
+		wl_surface_damage(display->cursor_surface, 0, 0,
+				  image->width, image->height);
+		wl_surface_commit(display->cursor_surface);
+	}
+
+}
+
+static void
+pointer_handle_leave(void *data, struct wl_pointer *pointer,
+		     uint32_t serial, struct wl_surface *surface)
+{
+}
+
+static void
+pointer_handle_motion(void *data, struct wl_pointer *pointer,
+		      uint32_t time, wl_fixed_t sx, wl_fixed_t sy)
+{
+
+}
+
+static void
+pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
+		      uint32_t serial, uint32_t time, uint32_t button,
+		      uint32_t state)
+{
+	struct display *display = data;
+
+	if (!display->window->xdg_surface)
+		return;
+
+	if (button == BTN_LEFT && state == WL_POINTER_BUTTON_STATE_PRESSED)
+		xdg_surface_move(display->window->xdg_surface,
+						 display->seat, serial);
+}
+
+static void
+pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
+		    uint32_t time, uint32_t axis, wl_fixed_t value)
+{
+}
+
+static const struct wl_pointer_listener pointer_listener = {
+	pointer_handle_enter,
+	pointer_handle_leave,
+	pointer_handle_motion,
+	pointer_handle_button,
+	pointer_handle_axis,
+};
+
+static void
+touch_handle_down(void *data, struct wl_touch *wl_touch,
+		  uint32_t serial, uint32_t time, struct wl_surface *surface,
+		  int32_t id, wl_fixed_t x_w, wl_fixed_t y_w)
+{
+	struct display *d = (struct display *)data;
+
+	if (!d->shell)
+		return;
+
+	xdg_surface_move(d->window->xdg_surface, d->seat, serial);
+}
+
+static void
+touch_handle_up(void *data, struct wl_touch *wl_touch,
+		uint32_t serial, uint32_t time, int32_t id)
+{
+}
+
+static void
+touch_handle_motion(void *data, struct wl_touch *wl_touch,
+		    uint32_t time, int32_t id, wl_fixed_t x_w, wl_fixed_t y_w)
+{
+}
+
+static void
+touch_handle_frame(void *data, struct wl_touch *wl_touch)
+{
+}
+
+static void
+touch_handle_cancel(void *data, struct wl_touch *wl_touch)
+{
+}
+
+static const struct wl_touch_listener touch_listener = {
+	touch_handle_down,
+	touch_handle_up,
+	touch_handle_motion,
+	touch_handle_frame,
+	touch_handle_cancel,
+};
+
+static void
+keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
+		       uint32_t format, int fd, uint32_t size)
+{
+}
+
+static void
+keyboard_handle_enter(void *data, struct wl_keyboard *keyboard,
+		      uint32_t serial, struct wl_surface *surface,
+		      struct wl_array *keys)
+{
+}
+
+static void
+keyboard_handle_leave(void *data, struct wl_keyboard *keyboard,
+		      uint32_t serial, struct wl_surface *surface)
+{
+}
+
+static void
+keyboard_handle_key(void *data, struct wl_keyboard *keyboard,
+		    uint32_t serial, uint32_t time, uint32_t key,
+		    uint32_t state)
+{
+	struct display *d = data;
+
+	if (!d->shell)
+		return;
+
+	if (key == KEY_F11 && state) {
+		if (d->window->fullscreen)
+			xdg_surface_unset_fullscreen(d->window->xdg_surface);
+		else
+			xdg_surface_set_fullscreen(d->window->xdg_surface, NULL);
+	} else if (key == KEY_ESC && state)
+		running = 0;
+}
+
+static void
+keyboard_handle_modifiers(void *data, struct wl_keyboard *keyboard,
+			  uint32_t serial, uint32_t mods_depressed,
+			  uint32_t mods_latched, uint32_t mods_locked,
+			  uint32_t group)
+{
+}
+
+static const struct wl_keyboard_listener keyboard_listener = {
+	keyboard_handle_keymap,
+	keyboard_handle_enter,
+	keyboard_handle_leave,
+	keyboard_handle_key,
+	keyboard_handle_modifiers,
+};
+
+static void
+seat_handle_capabilities(void *data, struct wl_seat *seat,
+			 enum wl_seat_capability caps)
+{
+	struct display *d = data;
+
+	if ((caps & WL_SEAT_CAPABILITY_POINTER) && !d->pointer) {
+		d->pointer = wl_seat_get_pointer(seat);
+		wl_pointer_add_listener(d->pointer, &pointer_listener, d);
+	} else if (!(caps & WL_SEAT_CAPABILITY_POINTER) && d->pointer) {
+		wl_pointer_destroy(d->pointer);
+		d->pointer = NULL;
+	}
+
+	if ((caps & WL_SEAT_CAPABILITY_KEYBOARD) && !d->keyboard) {
+		d->keyboard = wl_seat_get_keyboard(seat);
+		wl_keyboard_add_listener(d->keyboard, &keyboard_listener, d);
+	} else if (!(caps & WL_SEAT_CAPABILITY_KEYBOARD) && d->keyboard) {
+		wl_keyboard_destroy(d->keyboard);
+		d->keyboard = NULL;
+	}
+
+	if ((caps & WL_SEAT_CAPABILITY_TOUCH) && !d->touch) {
+		d->touch = wl_seat_get_touch(seat);
+		wl_touch_set_user_data(d->touch, d);
+		wl_touch_add_listener(d->touch, &touch_listener, d);
+	} else if (!(caps & WL_SEAT_CAPABILITY_TOUCH) && d->touch) {
+		wl_touch_destroy(d->touch);
+		d->touch = NULL;
+	}
+}
+
+static const struct wl_seat_listener seat_listener = {
+	seat_handle_capabilities,
+};
+
+
+static void
+xdg_shell_ping(void *data, struct xdg_shell *shell, uint32_t serial)
+{
+	xdg_shell_pong(shell, serial);
+}
+
+static const struct xdg_shell_listener xdg_shell_listener = {
+	xdg_shell_ping,
+};
+
+#define XDG_VERSION 5 /* The version of xdg-shell that we implement */
+#ifdef static_assert
+static_assert(XDG_VERSION == XDG_SHELL_VERSION_CURRENT,
+	      "Interface version doesn't match implementation version");
+#endif
+
+static void
+dmabuf_format(void *data, struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf, uint32_t format)
+{
+	fprintf(stderr, "debug: Support drm_format 0x%x \n", format);
+}
+
+static const struct zwp_linux_dmabuf_v1_listener dmabuf_listener = {
+	dmabuf_format
+};
+
+static void
+ddp_destroy(struct ddp_unit *ddp)
+{
+	config_ddp_prop_destroy(ddp->ddp_prop);
+	wl_list_remove(&ddp->link);
+	free(ddp);
+}
+
+static void
+display_add_ddp(struct display *d, uint32_t name, uint32_t version)
+{
+	struct ddp_unit *p;
+	struct window *window = d->window;
+
+	p = calloc(1, sizeof(*p));
+	assert(p);
+
+	p->ddp_prop = wl_registry_bind(d->registry, name,
+				     &config_ddp_prop_interface, 1);
+	p->name = name;
+	config_ddp_prop_add_listener(p->ddp_prop ,
+						&config_ddp_prop_listener, window);
+	wl_list_insert(&d->ddp_prox_list, &p->link);
+}
+
+static void
+registry_handle_global(void *data, struct wl_registry *registry,
+		       uint32_t name, const char *interface, uint32_t version)
+{
+	struct display *d = data;
+
+	if (strcmp(interface, "wl_compositor") == 0) {
+		d->compositor =
+			wl_registry_bind(registry, name,
+					 &wl_compositor_interface, 2);
+	} else if (strcmp(interface, "xdg_shell") == 0) {
+		d->shell = wl_registry_bind(registry, name,
+					    &xdg_shell_interface, 1);
+		xdg_shell_add_listener(d->shell, &xdg_shell_listener, d);
+		xdg_shell_use_unstable_version(d->shell, XDG_VERSION);
+	} else if (strcmp(interface, "wl_seat") == 0) {
+		d->seat = wl_registry_bind(registry, name,
+					   &wl_seat_interface, 1);
+		wl_seat_add_listener(d->seat, &seat_listener, d);
+	} else if (strcmp(interface, "zwp_fullscreen_shell_v1") == 0) {
+		d->fshell = wl_registry_bind(registry, name,
+					   &zwp_fullscreen_shell_v1_interface, 1);
+	} else if (strcmp(interface, "wl_shm") == 0) {
+		d->shm = wl_registry_bind(registry, name,
+					  &wl_shm_interface, 1);
+		d->cursor_theme = wl_cursor_theme_load(NULL, 32, d->shm);
+		if (!d->cursor_theme) {
+			fprintf(stderr, "unable to load default theme\n");
+			return;
+		}
+		d->default_cursor =
+			wl_cursor_theme_get_cursor(d->cursor_theme, "grabbing");
+		if (!d->default_cursor) {
+			fprintf(stderr, "unable to load default grabbing pointer\n");
+			// TODO: abort ?
+		}
+	} else if (strcmp(interface, "ivi_application") == 0) {
+		d->ivi_application =
+			wl_registry_bind(registry, name,
+					 &ivi_application_interface, 1);
+	} else if (strcmp(interface, "zwp_linux_dmabuf_v1") == 0) {
+		d->dmabuf = wl_registry_bind(registry, name,
+						&zwp_linux_dmabuf_v1_interface, 1);
+		zwp_linux_dmabuf_v1_add_listener(d->dmabuf, &dmabuf_listener, d);
+	} else if (strcmp(interface, "config_ddp_prop") == 0)
+		display_add_ddp(d, name, version);
+	else if (strcmp(interface, "config_switch") == 0) {
+		d->config_switch =
+			wl_registry_bind(registry, name,
+					 &config_switch_interface, 1);
+	}
+}
+
+static void
+registry_handle_global_remove(void *data, struct wl_registry *registry,
+			      uint32_t name)
+{
+	struct display *d = data;
+	struct ddp_unit *ddp, *dtmp;
+
+	wl_list_for_each_safe(ddp, dtmp, &d->ddp_prox_list, link) {
+		if (ddp->name != name)
+			continue;
+
+		ddp_destroy(ddp);
+	}
+}
+
+static const struct wl_registry_listener registry_listener = {
+	registry_handle_global,
+	registry_handle_global_remove
+};
+
+static void
+destroy_display(struct display *display)
+{
+	if (display->dmabuf)
+		zwp_linux_dmabuf_v1_destroy(display->dmabuf);
+
+	if (display->shell)
+		xdg_shell_destroy(display->shell);
+
+	if (display->fshell)
+		zwp_fullscreen_shell_v1_release(display->fshell);
+
+	if (display->compositor)
+		wl_compositor_destroy(display->compositor);
+
+	wl_surface_destroy(display->cursor_surface);
+	if (display->cursor_theme)
+		wl_cursor_theme_destroy(display->cursor_theme);
+
+	if (display->ivi_application)
+		ivi_application_destroy(display->ivi_application);
+
+	wl_registry_destroy(display->registry);
+	wl_display_flush(display->display);
+	wl_display_disconnect(display->display);
+	free(display);
+}
+
+static struct display *
+create_display(struct window *window)
+{
+	struct display *display;
+
+	display = malloc(sizeof *display);
+	if (display == NULL) {
+		fprintf(stderr, "out of memory\n");
+		exit(1);
+	}
+	display->display = wl_display_connect(NULL);
+	assert(display->display);
+	wl_list_init(&display->ddp_prox_list);
+	display->window = window;
+
+	display->registry = wl_display_get_registry(display->display);
+	wl_registry_add_listener(display->registry,
+				 &registry_listener, display);
+	wl_display_roundtrip(display->display);
+	if (display->dmabuf == NULL) {
+		fprintf(stderr, "No zwp_linux_dmabuf_v1 global found\n");
+		exit(1);
+	}
+	wl_display_roundtrip(display->display);
+
+	return display;
+}
+
+static void
+signal_int(int signum)
+{
+	running = 0;
+}
+
+/* input format <crtc_id:plane1_prop/plane2_prop/
+ * plane3_prop/plane4_prop> like:-zpos [30:2/1/0/3]
+ * so, you should know how many plane it has and
+ * what crtc_id you choose before.*/
+static int parse_ddp(struct window *window,
+							char *p, enum ddp_op_type type)
+{
+	int len;
+	int64_t tmp, *ptmp;
+	char *end, *pPos = p;
+
+	len = strlen(pPos);
+	if((pPos[0] != '[')||(pPos[len - 1] != ']'))
+		return -EINVAL;
+
+	pPos[len - 1] = '\0';
+	len -= 1;
+	pPos++;
+	/*according input adjust base(8, 10 or 16)*/
+	window->input_ddp.crtc_id = (uint32_t)strtoul(pPos, &end, 0);
+	if (*end != ':')
+		return -EINVAL;
+
+	len -= (end - pPos + 1);
+	pPos = end + 1;
+
+	while(*pPos != '\0') {
+		tmp = (int64_t)strtoll(pPos, &end, 0);
+		if ((*end != '/') && (*end != '\0'))
+			return -EINVAL;
+		switch(type) {
+		case DDP_OP_ALPHA:
+			ptmp = wl_array_add(&(window->input_ddp.alpha_array), sizeof(*ptmp));
+			*ptmp = tmp;
+			break;
+		case DDP_OP_COLORKEY:
+			ptmp = wl_array_add(&window->input_ddp.colorkey_array, sizeof(*ptmp));
+			*ptmp = tmp;
+			break;
+		case DDP_OP_ZPOS:
+			ptmp = wl_array_add(&window->input_ddp.zpos_array, sizeof(*ptmp));
+			*ptmp = tmp;
+			break;
+		case DDP_OP_BACKGROUND:
+			window->input_ddp.background = tmp;
+			break;
+		default:
+			break;
+		}
+		if (*end != '\0')
+			pPos = end + 1;
+		else
+			pPos = end;
+	}
+	window->input_ddp.type |= type;
+	return 0;
+}
+
+/*
+ * parse the message inputed for rawdata
+ * egg: -F /usr/share/weston/rawdata.nv16:720x480@5
+ * filename:widthxheight@format
+*/
+static int parse_file(struct file_arg *file, char *p)
+{
+	char *end;
+	char *pPos = p;
+	int len, i;
+
+	len = strlen(pPos) + 1;
+	for (i = 0; i < len; i++)
+		if(pPos[i] == ':')
+			pPos[i] = '\0';
+
+	memcpy(file->filename, pPos, strlen(pPos) + 1);
+	pPos = pPos + strlen(pPos) + 1;
+	file->width = strtoul(pPos, &end, 10);
+	if (*end != 'x')
+		return -EINVAL;
+	pPos = end + 1;
+	file->height = strtoul(pPos, &end, 10);
+	if (*end != '@')
+		return -EINVAL;
+	pPos = end + 1;
+	file->format = strtoul(pPos, &end, 10);
+	if (*end != '\0')
+		return -EINVAL;
+	return 0;
+}
+
+static void init_window(struct window *window)
+{
+	wl_array_init(&window->array);
+	wl_array_init(&window->input_ddp.alpha_array);
+	wl_array_init(&window->input_ddp.colorkey_array);
+	wl_array_init(&window->input_ddp.zpos_array);
+	window->input_ddp.type = DDP_OP_NONE;
+	window->geometry.width  = 0;
+	window->geometry.height = 0;
+	window->buffer_size = 32;
+	window->transform = WL_OUTPUT_TRANSFORM_NORMAL;
+	window->opaque = 1;
+	window->overlay = 0;
+	window->format = 0;
+	window->drm_card_fd = -1;
+}
+
+static void
+usage(int error_code)
+{
+	fprintf(stderr, "Usage: mtkdraw-dma [OPTIONS]\n\n"
+		"  -f           Run in fullscreen mode(only desktop-shell valid)\n"
+		"  -alpha       Set alpha for planes(0~0x3ff),\n"
+		"               if lower than 0, keep value to change\n"
+		"               /*ALPHA: bit7~0 alpha value, bit8 enable convert,\n"
+		"                 bit9 premultiplied alpha*/ \n"
+		"               eg:-alpha [crtc_id:0x-1/-1/0x155/-1]\n"
+		"  -colorkey    Set colorkey for planes(0~0xffffffff),\n"
+		"               if lower than 0, keep value to change\n"
+		"               /*COLORKEY: bit31~0 ARGB data*/ \n"
+		"               eg:-colorkey [crtc_id:-1/-1/0xff0000ff/-1]\n"
+		"  -zpos        Set zpos for planes(0~3), if lower than 0,\n"
+		"               keep value to change\n"
+		"               eg:-zpos [crtc_id:3/-1/-1/0]\n\n"
+		"  Notice: alpha/colorkey/zpos only commit the plane that is using\n\n"
+		"  -background  Set background for crtc(0~0xffffff),\n"
+		"               if lower than 0, keep value to change\n"
+		"  -o           Create an opaque surface\n"
+		"  -s           Use a 16 bpp EGL config\n"
+		"  -t           Set display buffer transform(0~7)\n"
+		"  -F           rawdata message(rawdata size provided is 320x480)\n"
+		"               eg:-F /usr/share/weston/rawdata.nv16:320x480@5\n"
+		"               @14 stand for nv16 format, formats supported as follows\n"
+		"               now only support 8 formats\n"
+		"                   0 --> IMG_FORMAT_RGB565\n"
+		"                   1 --> IMG_FORMAT_XRGB8888\n"
+		"                   2 --> IMG_FORMAT_ARGB8888\n"
+		"                   3 --> IMG_FORMAT_YUYV\n"
+		"                   4 --> IMG_FORMAT_NV12\n"
+		"                   5 --> IMG_FORMAT_NV16\n"
+		"                   6 --> IMG_FORMAT_YUV420\n"
+		"                   7 --> IMG_FORMAT_YVU420\n"
+		"  -d           Enable debug output\n"
+		"  -overlay     Enable overlay switch\n"
+		"  -h           This help text\n\n");
+
+	exit(error_code);
+}
+
+int
+main(int argc, char **argv)
+{
+	struct sigaction sigint;
+	struct display *display;
+	struct window  window  = { 0 };
+	int i, ret = 0;
+	struct file_arg *file;
+	struct ddp_unit *posddp, *tmpddp;
+
+	init_window(&window);
+
+	for (i = 1; i < argc; i++) {
+		if (strcmp("-f", argv[i]) == 0)
+			window.fullscreen = 1;
+		else if (strcmp("-o", argv[i]) == 0)
+			window.opaque = 0;
+		else if (strcmp("-s", argv[i]) == 0)
+			window.buffer_size = 16;
+		else if (strcmp("-t", argv[i]) == 0)
+			window.transform = atoi(argv[++i]);
+		else if (strcmp("-alpha", argv[i]) == 0) {
+			ret = parse_ddp(&window, argv[++i], DDP_OP_ALPHA);
+			if (ret < 0)
+				fprintf(stderr, "error: input error, like(4 planes): "
+					"-alpha [crtc_id:alpha1/alpha2/alpha3/alpha4]\n");
+		}
+		else if (strcmp("-colorkey", argv[i]) == 0) {
+			ret = parse_ddp(&window, argv[++i], DDP_OP_COLORKEY);
+			if (ret < 0)
+				fprintf(stderr, "error: input error, like(4 planes): -colorkey "
+					"[crtc_id:colorkey1/colorkey2/colorkey3/colorkey4]\n");
+		}
+		else if (strcmp("-zpos", argv[i]) == 0) {
+			ret = parse_ddp(&window, argv[++i], DDP_OP_ZPOS);
+			if (ret < 0)
+				fprintf(stderr, "error: input error, like(4 planes): -zpos "
+					"[crtc_id:zpos1/zpos2/zpos3/zpos4]\n");
+		} else if (strcmp("-background", argv[i]) == 0) {
+			ret = parse_ddp(&window, argv[++i], DDP_OP_BACKGROUND);
+			if (ret < 0)
+				fprintf(stderr, "error: input error, like: -background "
+					"[crtc_id:background\n");
+		}
+		else if (strcmp("-F", argv[i]) == 0){
+			ret = parse_file(&window.image.fProp, argv[++i]);
+			if (ret < 0)
+				fprintf(stderr, "error: input error, like: -F "
+					"/usr/share/weston/rawdata.nv16:320x480@5\n");
+		}
+		else if (strcmp("-d", argv[i]) == 0)
+			debug = 1;
+		else if (strcmp("-overlay", argv[i]) == 0)
+			window.overlay = 1;
+		else if (strcmp("-h", argv[i]) == 0)
+			usage(EXIT_SUCCESS);
+		else
+			usage(EXIT_FAILURE);
+	}
+
+	file = &window.image.fProp;
+	if((file->width == 0) || (file->height ==0) || (file->filename == 0))
+	{
+		/*default sample*/
+		file->width = 320;
+		file->height = 480;
+		file->format = IMG_FORMAT_NV16;
+		snprintf(file->filename, MAX_LEN, "/usr/share/weston/rawdata.nv16");
+		fprintf(stderr, "debug: You have choose the default example!\n");
+	}
+
+	fprintf(stderr, "debug: The file is %s width/height/format[%d %d %d]\n",
+		file->filename, file->width, file->height, file->format);
+
+	window.geometry.width  = file->width;
+	window.geometry.height = file->height;
+	window.window_size = window.geometry;
+
+	display = create_display(&window);
+	window.display = display;
+	//display->window = &window;
+
+	create_surface(&window);
+	
+	ret = init_img_texture(&window);
+	if (ret < 0){
+		fprintf(stderr, "error: init_img_texture failed\n");
+		return -1;
+	}
+
+	window.drm_card_fd = _kms_device_fd();
+	if (window.drm_card_fd < 0) {
+		fprintf(stderr, "error: fail to get drm_card_fd !\n");
+		return -1;
+	}
+	/*
+	  * setting sprite_switch = 0, indicate not walk overlay
+	  * setting sprite_switch = 1, indicate walk overlay
+	*/
+	if(window.overlay)
+		config_switch_set_sprite_switch(window.switch_set, 1);
+	else
+		config_switch_set_sprite_switch(window.switch_set, 0);
+
+	sigint.sa_handler = signal_int;
+	sigemptyset(&sigint.sa_mask);
+	sigint.sa_flags = SA_RESETHAND;
+	sigaction(SIGINT, &sigint, NULL);
+
+	if (window.input_ddp.type != DDP_OP_NONE) {
+			ret = config_set_ddp_props(&window);
+			if (ret < 0)
+				return -1;
+	}
+	redraw(&window, NULL, 0);
+
+	while (running && ret != -1)
+		ret = wl_display_dispatch(display->display);
+
+	fprintf(stderr, "debug: simple-configure-mtk exiting\n");
+	destroy_surface(&window);
+	/*send message to server to logout resource.*/
+	wl_list_for_each_safe(posddp, tmpddp, &display->ddp_prox_list, link) {
+		ddp_destroy(posddp);
+	}
+
+	destroy_display(display);
+
+	return 0;
+}
+
+
diff --git a/clients/simple-egl.c b/clients/simple-egl.c
index d8233c1..6068530 100644
--- a/clients/simple-egl.c
+++ b/clients/simple-egl.c
@@ -45,6 +45,7 @@
 #include <sys/types.h>
 #include <unistd.h>
 #include "protocol/ivi-application-client-protocol.h"
+#include "protocol/weston-configure-mtk-client-protocol.h"
 #define IVI_SURFACE_ID 9000
 
 #include "shared/platform.h"
@@ -82,6 +83,7 @@ struct display {
 	} egl;
 	struct window *window;
 	struct ivi_application *ivi_application;
+	struct config_switch *config_switch;
 
 	PFNEGLSWAPBUFFERSWITHDAMAGEEXTPROC swap_buffers_with_damage;
 };
@@ -106,7 +108,8 @@ struct window {
 	struct ivi_surface *ivi_surface;
 	EGLSurface egl_surface;
 	struct wl_callback *callback;
-	int fullscreen, opaque, buffer_size, frame_sync;
+	int fullscreen, opaque, buffer_size, frame_sync, overlay;
+	struct config_switch_set *switch_set;
 };
 
 static const char *vert_shader_text =
@@ -382,6 +385,8 @@ create_surface(struct window *window)
 
 	window->surface = wl_compositor_create_surface(display->compositor);
 
+	window->switch_set = config_switch_connect(display->config_switch, window->surface);
+
 	window->native =
 		wl_egl_window_create(window->surface,
 				     window->geometry.width,
@@ -790,6 +795,10 @@ registry_handle_global(void *data, struct wl_registry *registry,
 		d->ivi_application =
 			wl_registry_bind(registry, name,
 					 &ivi_application_interface, 1);
+	} else if (strcmp(interface, "config_switch") == 0) {
+		d->config_switch =
+			wl_registry_bind(registry, name,
+					 &config_switch_interface, 1);
 	}
 }
 
@@ -814,11 +823,12 @@ static void
 usage(int error_code)
 {
 	fprintf(stderr, "Usage: simple-egl [OPTIONS]\n\n"
-		"  -f\tRun in fullscreen mode\n"
-		"  -o\tCreate an opaque surface\n"
-		"  -s\tUse a 16 bpp EGL config\n"
-		"  -b\tDon't sync to compositor redraw (eglSwapInterval 0)\n"
-		"  -h\tThis help text\n\n");
+		"  -f        Run in fullscreen mode\n"
+		"  -o        Create an opaque surface\n"
+		"  -s        Use a 16 bpp EGL config\n"
+		"  -b        Don't sync to compositor redraw (eglSwapInterval 0)\n"
+		"  -overlay  Walk overlay path prior\n"
+		"  -h        This help text\n\n");
 
 	exit(error_code);
 }
@@ -838,6 +848,7 @@ main(int argc, char **argv)
 	window.window_size = window.geometry;
 	window.buffer_size = 32;
 	window.frame_sync = 1;
+	window.overlay = 0;
 
 	for (i = 1; i < argc; i++) {
 		if (strcmp("-f", argv[i]) == 0)
@@ -848,6 +859,8 @@ main(int argc, char **argv)
 			window.buffer_size = 16;
 		else if (strcmp("-b", argv[i]) == 0)
 			window.frame_sync = 0;
+		else if (strcmp("-overlay", argv[i]) == 0)
+			window.overlay = 1;
 		else if (strcmp("-h", argv[i]) == 0)
 			usage(EXIT_SUCCESS);
 		else
@@ -867,6 +880,15 @@ main(int argc, char **argv)
 	create_surface(&window);
 	init_gl(&window);
 
+	/*
+	  * setting sprite_switch = 0, indicate not walk overlay
+	  * setting sprite_switch = 1, indicate walk overlay
+	*/
+	if(window.overlay)
+		config_switch_set_sprite_switch(window.switch_set, 1);
+	else
+		config_switch_set_sprite_switch(window.switch_set, 0);
+
 	display.cursor_surface =
 		wl_compositor_create_surface(display.compositor);
 
diff --git a/configure.ac b/configure.ac
index 240966f..86d2172 100644
--- a/configure.ac
+++ b/configure.ac
@@ -387,6 +387,7 @@ if ! test "x$enable_simple_dmabuf_v4l_client" = "xno"; then
   enable_simple_dmabuf_v4l_client="$have_simple_dmabuf_v4l_client"
 fi
 AM_CONDITIONAL(BUILD_SIMPLE_DMABUF_V4L_CLIENT, test "x$enable_simple_dmabuf_v4l_client" = "xyes")
+AM_CONDITIONAL(BUILD_SIMPLE_CONFIGURE_MTK_CLIENT, test "x$enable_simple_dmabuf_v4l_client" = "xyes")
 
 AC_ARG_ENABLE(clients, [  --enable-clients],, enable_clients=yes)
 AM_CONDITIONAL(BUILD_CLIENTS, test x$enable_clients = xyes)
diff --git a/protocol/weston-configure-mtk.xml b/protocol/weston-configure-mtk.xml
new file mode 100644
index 0000000..3d96c2a
--- /dev/null
+++ b/protocol/weston-configure-mtk.xml
@@ -0,0 +1,130 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="weston_configure_mtk">
+
+  <copyright>
+    Copyright (C) 2016 MediaTek
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice (including the next
+    paragraph) shall be included in all copies or substantial portions of the
+    Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+  </copyright>
+
+  <interface name="config_switch_set" version="1">
+    <description summary="app interface for setting configure for the surface"/>
+
+    <request name="sprite_switch">
+      <description summary="setting the surface configure">
+       This set view matched with the surface to show in overlay plane if
+       overlay planes are available.Otherwise, it walk primary plane to
+       render, and then send to drm to show.
+      </description>
+	  <arg name="sprite_switch" type="int"/>
+    </request>
+  </interface>
+
+  <interface name="config_switch" version="1">
+    <description summary="create app configure path for setting parameter">
+      This interface is exposed as a global singleton.
+      This interface is implemented by server, it mainly provide channel to allow
+      client to control some properties.
+    </description>
+
+    <request name="connect">
+      <description summary="connect to server for setting parameter">
+        This request gives client way to connect server.In fact, parameters set by
+        app all through wl_surface because this is only way can be transmit by app.
+      </description>
+      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
+      <arg name="id" type="new_id" interface="config_switch_set"/>
+    </request>
+
+  </interface>
+
+  <interface name="config_ddp_prop" version="1">
+    <description summary="app interface for setting configure for drm resource"/>
+
+    <request name="set_plane_zpos">
+      <description summary="set plane's zposition">
+        This expose interface to client to change planes' zposition.
+	zpos's type is array, every meta in array is uint_64, the upper
+	31 bits stand for plane_id, the lower 33 bits is value of zpos.
+      </description>
+	  <arg name="crtc_id" type="uint"/>
+	  <arg name="zpos" type="array"/>
+    </request>
+
+    <request name="set_plane_colorkey">
+      <description summary="set plane's colorkey">
+        This expose interface to client to change planes' colorkey.
+	colorkey's type is array, every meta in array is uint_64, the upper
+	31 bits stand for plane_id, the lower 33 bits is value of colorkey.
+      </description>
+	  <arg name="crtc_id" type="uint"/>
+	  <arg name="colorkey" type="array"/>
+    </request>
+
+    <request name="set_plane_alpha">
+      <description summary="set plane's alpha">
+        This expose interface to client to change planes' alpha.
+	alpha's type is array, every meta in array is uint_64, the upper
+	31 bits stand for plane_id, the lower 33 bits is value of alpha.
+      </description>
+	  <arg name="crtc_id" type="uint"/>
+	  <arg name="alpha" type="array"/>
+    </request>
+
+    <request name="set_crtc_background">
+      <description summary="set crtc's background">
+        This expose interface to client to change crtc' background.
+      </description>
+	  <arg name="crtc_id" type="uint"/>
+	  <arg name="background" type="int"/>
+    </request>
+
+    <event name="plane_param">
+      <description summary="send plane's parameters to client">
+        This expose interface to client to get drm plane resource.
+      </description>
+	  <arg name="crtc_id" 	type="uint"/>
+	  <arg name="alpha" 	type="uint"/>
+	  <arg name="colorkey" 	type="uint"/>
+	  <arg name="zpos" 	type="uint"/>
+	  <arg name="plane_id" 	type="uint"/>
+	  <arg name="type" 	type="int"/>
+    </event>
+
+    <enum name="plane_type">
+      <description summary="drm plane type">
+      </description>
+      <entry name="primary"	value="0x0" summary="primary plane"/>
+      <entry name="overlay"	value="0x1" summary="overlay plane"/>
+	  <entry name="cursor"	value="0x2" summary="cursor plane"/>
+    </enum>
+
+    <event name="crtc_param">
+      <description summary="send crtc's parameters to client">
+        This expose interface to client to get drm crtc resource.
+      </description>
+	  <arg name="background" 	type="int"/>
+	  <arg name="crtc_id" 		type="uint"/>
+    </event>
+
+  </interface>
+
+</protocol>
+
diff --git a/src/compositor-drm.c b/src/compositor-drm.c
index 056cbcd..6aaff5f 100644
--- a/src/compositor-drm.c
+++ b/src/compositor-drm.c
@@ -58,6 +58,7 @@
 #include "vaapi-recorder.h"
 #include "presentation-time-server-protocol.h"
 #include "linux-dmabuf.h"
+#include "weston-configure-mtk.h"
 
 #define ATOMIC_DEBUG getenv("ATOMIC_DEBUG")
 
@@ -92,6 +93,10 @@ enum wdrm_plane_property {
 	WDRM_PLANE_CRTC_H,
 	WDRM_PLANE_FB_ID,
 	WDRM_PLANE_CRTC_ID,
+	WDRM_PLANE_ROTATE,
+	WDRM_PLANE_ALPHA,
+	WDRM_PLANE_COLORKEY,
+	WDRM_PLANE_ZPOS,
 	WDRM_PLANE__COUNT
 };
 
@@ -111,6 +116,7 @@ enum wdrm_plane_type {
 enum wdrm_crtc_property {
 	WDRM_CRTC_MODE_ID = 0,
 	WDRM_CRTC_ACTIVE,
+	WDRM_CRTC_BACKGROUND,
 	WDRM_CRTC__COUNT
 };
 
@@ -297,6 +303,13 @@ struct drm_plane {
 	uint32_t src_w, src_h;
 	uint32_t dest_x, dest_y;
 	uint32_t dest_w, dest_h;
+	int32_t rotation;
+	struct{
+		uint32_t alpha;
+		uint32_t colorkey;
+		uint32_t zpos;
+		enum plane_prop_changed dirty;
+	}plane_config;
 
 	struct wl_list flip_link; /* drm_output::plane_flip_list */
 
@@ -306,17 +319,22 @@ struct drm_plane {
 struct drm_output {
 	struct weston_output   base;
 
-	uint32_t crtc_id;
+	struct {
+		uint32_t crtc_id;
+		int32_t crtc_background;
+		drmModeCrtcPtr original_crtc;
+		struct crtc_properties props_crtc;
+		enum crtc_prop_changed dirty;
+	} ddp_crtc;
+
 	int pipe;
 	uint32_t connector_id;
-	drmModeCrtcPtr original_crtc;
 	struct drm_edid edid;
 	drmModePropertyPtr dpms_prop;
 	uint32_t gbm_format;
 
 	enum dpms_enum dpms;
 
-	struct crtc_properties props_crtc;
 	struct connector_properties props_conn;
 
 	int vblank_pending;
@@ -590,6 +608,10 @@ plane_properties_init(struct drm_plane *plane)
 		[WDRM_PLANE_CRTC_H] = "CRTC_H",
 		[WDRM_PLANE_FB_ID] = "FB_ID",
 		[WDRM_PLANE_CRTC_ID] = "CRTC_ID",
+		[WDRM_PLANE_ROTATE] = "rotation",
+		[WDRM_PLANE_ALPHA] = "alpha",
+		[WDRM_PLANE_COLORKEY] = "colorkey",
+		[WDRM_PLANE_ZPOS] = "zpos",
 	};
 	static const char * const plane_type_names[] = {
 		[WDRM_PLANE_TYPE_PRIMARY] = "Primary",
@@ -625,7 +647,7 @@ plane_properties_init(struct drm_plane *plane)
 				(1 << WDRM_PLANE_CRTC_W) | (1 << WDRM_PLANE_CRTC_H) | \
 				(1 << WDRM_PLANE_FB_ID) | (1 << WDRM_PLANE_CRTC_ID);
 
-			if (plane->props.value_valid_mask != required_mask) {
+			if ((plane->props.value_valid_mask & required_mask) != required_mask) {
 				weston_log("DRM error: failed to look up all plane properties "
 					   "(wanted 0x%x got 0x%x) on ID %d\n",
 					   required_mask, plane->props.value_valid_mask,
@@ -681,6 +703,7 @@ static bool output_properties_init(struct drm_output *output)
 	static const char * const crtc_property_names[] = {
 		[WDRM_CRTC_MODE_ID] = "MODE_ID",
 		[WDRM_CRTC_ACTIVE] = "ACTIVE",
+		[WDRM_CRTC_BACKGROUND] = "background",
 	};
 	static const char * const connector_property_names[] = {
 		[WDRM_CONNECTOR_CRTC_ID] = "CRTC_ID",
@@ -697,26 +720,29 @@ static bool output_properties_init(struct drm_output *output)
 	static_assert(WDRM_CONNECTOR__COUNT <= 32,
 		      "need more bits for connector item_valid_mask");
 
-	output->props_crtc.value_valid_mask =
+	output->ddp_crtc.props_crtc.value_valid_mask =
 		drm_properties_get_from_obj(b,
-					    output->props_crtc.item,
+					    output->ddp_crtc.props_crtc.item,
 					    crtc_property_names,
 					    WDRM_CRTC__COUNT,
-					    output->crtc_id,
+					    output->ddp_crtc.crtc_id,
 					    DRM_MODE_OBJECT_CRTC);
 
 	required_mask = 0;
 	if (b->atomic_modeset) {
 		required_mask |= (1 << WDRM_CRTC_MODE_ID) | \
 				 (1 << WDRM_CRTC_ACTIVE);
-		if (output->props_crtc.value_valid_mask != required_mask) {
+		if ((output->ddp_crtc.props_crtc.value_valid_mask &required_mask) != required_mask) {
 			weston_log("DRM error: failed to look up all CRTC properties "
 				   "(wanted 0x%x got 0x%x) on ID %d\n",
-				   required_mask, output->props_crtc.value_valid_mask,
-				   output->crtc_id);
+				   required_mask, output->ddp_crtc.props_crtc.value_valid_mask,
+				   output->ddp_crtc.crtc_id);
 			return false;
 		}
 	}
+	output->ddp_crtc.crtc_background =
+		(int32_t)(output->ddp_crtc.props_crtc.item[WDRM_CRTC_BACKGROUND].value);
+	output->ddp_crtc.dirty = CRTC_NO_CHANGED;
 
 	output->props_conn.value_valid_mask =
 		drm_properties_get_from_obj(b,
@@ -749,8 +775,8 @@ static bool output_properties_init(struct drm_output *output)
  */
 static void output_properties_release(struct drm_output *output)
 {
-	property_item_array_release(output->props_crtc.item, WDRM_CRTC__COUNT);
-	output->props_crtc.value_valid_mask = 0;
+	property_item_array_release(output->ddp_crtc.props_crtc.item, WDRM_CRTC__COUNT);
+	output->ddp_crtc.props_crtc.value_valid_mask = 0;
 	property_item_array_release(output->props_conn.item,
 				    WDRM_CONNECTOR__COUNT);
 	output->props_conn.value_valid_mask = 0;
@@ -813,8 +839,8 @@ static void
 crtc_property_debug(struct drm_output *output,
 		    enum wdrm_crtc_property prop, uint64_t value)
 {
-	property_debug("CRTC", output->crtc_id, output->props_crtc.item,
-		       WDRM_CRTC__COUNT, prop, value);
+	property_debug("CRTC", output->ddp_crtc.crtc_id,
+			output->ddp_crtc.props_crtc.item, WDRM_CRTC__COUNT, prop, value);
 }
 
 static void
@@ -832,13 +858,14 @@ drm_plane_update_success(struct drm_plane *sprite)
 static void
 drm_crtc_update_begin(struct drm_output *output)
 {
-	output->props_crtc.value_pend_mask = 0;
+	output->ddp_crtc.props_crtc.value_pend_mask = 0;
 }
 
 static void
 drm_crtc_update_success(struct drm_output *output)
 {
-	output->props_crtc.value_valid_mask |= output->props_crtc.value_pend_mask;
+	output->ddp_crtc.props_crtc.value_valid_mask |=
+			output->ddp_crtc.props_crtc.value_pend_mask;
 }
 
 static void
@@ -912,25 +939,25 @@ static int
 atomic_crtc_add(drmModeAtomicReq *req, struct drm_output *output,
 		enum wdrm_crtc_property prop, uint64_t value)
 {
-	struct property_item *item = &output->props_crtc.item[prop];
+	struct property_item *item = &output->ddp_crtc.props_crtc.item[prop];
 	uint32_t mask = 1U << prop;
 
 	if (!item->id)
 		return -1;
 
-	if ((output->props_crtc.value_valid_mask |
-	     output->props_crtc.value_pend_mask) & mask &&
+	if ((output->ddp_crtc.props_crtc.value_valid_mask |
+	     output->ddp_crtc.props_crtc.value_pend_mask) & mask &&
 	    item->value == value)
 		return 0;
 
 	crtc_property_debug(output, prop, value);
 
-	if (drmModeAtomicAddProperty(req, output->crtc_id, item->id, value) < 0)
+	if (drmModeAtomicAddProperty(req, output->ddp_crtc.crtc_id, item->id, value) < 0)
 		return -1;
 
-	output->props_crtc.value_valid_mask &= ~mask;
+	output->ddp_crtc.props_crtc.value_valid_mask &= ~mask;
 	item->value = value;
-	output->props_crtc.value_pend_mask |= mask;
+	output->ddp_crtc.props_crtc.value_pend_mask |= mask;
 
 	return 0;
 }
@@ -953,7 +980,7 @@ drm_plane_crtc_supported(struct drm_output *output, uint32_t supported)
 	int crtc;
 
 	for (crtc = 0; crtc < b->num_crtcs; crtc++) {
-		if (b->crtcs[crtc] != output->crtc_id)
+		if (b->crtcs[crtc] != output->ddp_crtc.crtc_id)
 			continue;
 
 		if (supported & (1 << crtc))
@@ -1394,16 +1421,118 @@ drm_output_set_gamma(struct weston_output *output_base,
 	/* check */
 	if (output_base->gamma_size != size)
 		return;
-	if (!output->original_crtc)
+	if (!output->ddp_crtc.original_crtc)
 		return;
 
 	rc = drmModeCrtcSetGamma(backend->drm.fd,
-				 output->crtc_id,
+				 output->ddp_crtc.crtc_id,
 				 size, r, g, b);
 	if (rc)
 		weston_log("set gamma failed: %m\n");
 }
 
+static int
+drm_set_ddp_prop(struct weston_output *output_base, struct ddp_prop *ddp)
+{
+	struct drm_output *output = (struct drm_output *) output_base;
+	struct drm_backend *backend =
+		(struct drm_backend *)output->base.compositor->backend;
+	struct plane_base_prop *posplane, *tmplane;
+	struct drm_plane *plane;
+
+	wl_list_for_each_safe(posplane, tmplane, &ddp->plane_list, link) {
+		if(posplane->dirty == PLANE_NO_CHANGED)
+			continue;
+
+		wl_list_for_each(plane, &backend->plane_list, link) {
+			if (!drm_plane_crtc_supported(output, plane->possible_crtcs))
+				continue;
+
+			if (plane->plane_id == posplane->plane_id) {
+				if (posplane->dirty & PLANE_ALPHA_CHANGED) {
+					/*only changed can assign new value.*/
+					plane->plane_config.alpha = posplane->alpha;
+					plane->plane_config.dirty |= PLANE_ALPHA_CHANGED;
+					posplane->dirty &= ~PLANE_ALPHA_CHANGED;
+				} else if (posplane->dirty & PLANE_COLORKEY_CHANGED) {
+					plane->plane_config.colorkey = posplane->colorkey;
+					plane->plane_config.dirty |= PLANE_COLORKEY_CHANGED;
+					posplane->dirty &= ~PLANE_COLORKEY_CHANGED;
+				} else if (posplane->dirty & PLANE_ZPOS_CHANGED) {
+					plane->plane_config.zpos = posplane->zpos;
+					plane->plane_config.dirty |= PLANE_ZPOS_CHANGED;
+					posplane->dirty &= ~PLANE_ZPOS_CHANGED;
+				} else {
+					weston_log("error: the value(%d) of plane_prop_changed"
+								" seems not correct\n", posplane->dirty);
+					return -1;
+				}
+				weston_log("debug: %d plane_id = %u prop value alpha/colorkey/zpos] = "
+						"[%d %d %d]\n", __LINE__, plane->plane_id, plane->plane_config.alpha,
+						plane->plane_config.colorkey, plane->plane_config.zpos);
+			} else
+				continue;
+		}
+	}
+
+	while (ddp->crtc_dirty != CRTC_NO_CHANGED) {
+		if (ddp->crtc_dirty & CRTC_BACKGROUND_CHANGED) {
+			output->ddp_crtc.crtc_background = ddp->crtc_background;
+			output->ddp_crtc.dirty |= CRTC_BACKGROUND_CHANGED;
+			ddp->crtc_dirty &= ~CRTC_BACKGROUND_CHANGED;
+		} else
+			weston_log("error: the value of crtc_prop_changed"
+					" seems not correct\n");
+	}
+	return 0;
+}
+
+static int
+drm_get_ddp_prop(struct weston_output *output_base, struct ddp_prop *ddp)
+{
+	struct drm_output *output = (struct drm_output *) output_base;
+	struct drm_backend *backend =
+		(struct drm_backend *)output->base.compositor->backend;
+	struct plane_base_prop *plane_prop ;
+	struct drm_plane *plane;
+
+	plane_prop = malloc((sizeof (*plane_prop)));
+	if (!plane_prop) {
+			weston_log("fail to malloc for plane_prop\n");
+			return -1;
+	}
+
+	wl_list_for_each(plane, &backend->plane_list, link) {
+		if (!drm_plane_crtc_supported(output, plane->possible_crtcs))
+			continue;
+
+		plane_prop = malloc((sizeof (*plane_prop)));
+		if (!plane_prop) {
+				weston_log("fail to malloc for plane_prop\n");
+				return -1;
+		}
+		wl_list_init(&plane_prop->link);
+		/*get plane's properties tmp solution*/
+		plane_prop->alpha = plane->plane_config.alpha;
+		plane_prop->colorkey = plane->plane_config.colorkey ;
+		plane_prop->zpos = plane->plane_config.zpos ;
+		plane_prop->plane_id = plane->plane_id;
+		plane_prop->type = plane->type;
+		plane_prop->dirty = PLANE_NO_CHANGED;
+		/*to state the plane belong which crtc*/
+		plane_prop->crtc_id = output->ddp_crtc.crtc_id;
+
+		wl_list_insert(&ddp->plane_list, &plane_prop->link);
+	}
+
+	/*get crtc properties*/
+	ddp->crtc_id = output->ddp_crtc.crtc_id;
+	ddp->crtc_background= output->ddp_crtc.crtc_background;
+	ddp->crtc_dirty = CRTC_NO_CHANGED;
+
+	return 0;
+}
+
 /**
  * Populates an existing atomic request with the properties required for a
  * full modeset.
@@ -1428,7 +1557,7 @@ drm_output_populate_atomic_modeset(struct drm_output *output,
 	int ret = 0;
 
 	if (force) {
-		output->props_crtc.value_valid_mask = 0;
+		output->ddp_crtc.props_crtc.value_valid_mask = 0;
 		output->props_conn.value_valid_mask = 0;
 	}
 
@@ -1452,15 +1581,30 @@ drm_output_populate_atomic_modeset(struct drm_output *output,
 	}
 
 	ret |= atomic_connector_add(req, output, WDRM_CONNECTOR_CRTC_ID,
-				    enable ? output->crtc_id : 0);
+				    enable ? output->ddp_crtc.crtc_id : 0);
 	ret |= atomic_crtc_add(req, output, WDRM_CRTC_MODE_ID,
 			       enable ? mode->blob_id : 0);
 	ret |= atomic_crtc_add(req, output, WDRM_CRTC_ACTIVE, enable);
+	/*check if need to commit change for crtc*/
+	while (output->ddp_crtc.dirty != CRTC_NO_CHANGED) {
+		if (output->ddp_crtc.dirty & CRTC_BACKGROUND_CHANGED) {
+				ret |= atomic_crtc_add(req, output, WDRM_CRTC_BACKGROUND,
+										output->ddp_crtc.crtc_background);
+				output->ddp_crtc.props_crtc.item[WDRM_CRTC_BACKGROUND].value =
+										(uint64_t)(output->ddp_crtc.crtc_background);
+				output->ddp_crtc.dirty &= ~CRTC_BACKGROUND_CHANGED;
+		} else {
+			weston_log("error: the value of crtc_prop_changed"
+					" seems not correct\n");
+			return -1;
+		}
+	}
+	assert(output->ddp_crtc.dirty == CRTC_NO_CHANGED);
 
 	if (ret)
 		return -1;
 
-	if (!output->props_crtc.value_pend_mask &&
+	if (!output->ddp_crtc.props_crtc.value_pend_mask &&
 	    !output->props_conn.value_pend_mask)
 		return 0;
 
@@ -1511,7 +1655,7 @@ drm_output_populate_atomic_plane(struct drm_output *output, struct drm_plane *p,
 	struct drm_backend *backend =
 		(struct drm_backend *) output->base.compositor->backend;
 	uint32_t fb_id = 0;
-	int ret = 0;
+	int ret = 0, dirty = 0;
 
 	if (force)
 		p->props.value_valid_mask = 0;
@@ -1535,7 +1679,7 @@ drm_output_populate_atomic_plane(struct drm_output *output, struct drm_plane *p,
 
 	drm_plane_update_begin(p);
 	ret |= atomic_plane_add(req, p, WDRM_PLANE_CRTC_ID,
-				output ? output->crtc_id : 0);
+				output ? output->ddp_crtc.crtc_id : 0);
 	ret |= atomic_plane_add(req, p, WDRM_PLANE_FB_ID, fb_id);
 	ret |= atomic_plane_add(req, p, WDRM_PLANE_SRC_X, p->src_x);
 	ret |= atomic_plane_add(req, p, WDRM_PLANE_SRC_Y, p->src_y);
@@ -1545,6 +1689,43 @@ drm_output_populate_atomic_plane(struct drm_output *output, struct drm_plane *p,
 	ret |= atomic_plane_add(req, p, WDRM_PLANE_CRTC_Y, p->dest_y);
 	ret |= atomic_plane_add(req, p, WDRM_PLANE_CRTC_W, p->dest_w);
 	ret |= atomic_plane_add(req, p, WDRM_PLANE_CRTC_H, p->dest_h);
+	atomic_plane_add(req, p, WDRM_PLANE_ROTATE, p->rotation);
+
+	dirty = p->plane_config.dirty;
+	while (p->plane_config.dirty != PLANE_NO_CHANGED) {
+		if (p->plane_config.dirty & PLANE_ALPHA_CHANGED) {
+			ret |= atomic_plane_add(req, p,
+				WDRM_PLANE_ALPHA, p->plane_config.alpha);
+			if (force)
+				p->props.item[WDRM_PLANE_ALPHA].value =
+							(uint64_t)(p->plane_config.alpha);
+
+			p->plane_config.dirty &= ~PLANE_ALPHA_CHANGED;
+		} else if (p->plane_config.dirty & PLANE_COLORKEY_CHANGED) {
+			ret |= atomic_plane_add(req, p,
+				WDRM_PLANE_COLORKEY, p->plane_config.colorkey);
+			if (force)
+				p->props.item[WDRM_PLANE_COLORKEY].value =
+							(uint64_t)(p->plane_config.colorkey);
+
+				p->plane_config.dirty &= ~PLANE_COLORKEY_CHANGED;
+		} else if (p->plane_config.dirty & PLANE_ZPOS_CHANGED) {
+			ret |= atomic_plane_add(req, p,
+				WDRM_PLANE_ZPOS, p->plane_config.zpos);
+			if (force)
+				p->props.item[WDRM_PLANE_ZPOS].value =
+							(uint64_t)(p->plane_config.zpos);
+
+				p->plane_config.dirty &= ~PLANE_ZPOS_CHANGED;
+		} else {
+			weston_log("error: the value of plane_prop_changed"
+					" seems not correct\n");
+			return -1;
+		}
+	}
+	assert(p->plane_config.dirty == PLANE_NO_CHANGED);
+	if (!force)
+		p->plane_config.dirty = dirty;
 
 	if (ret)
 		return -1;
@@ -1587,7 +1768,8 @@ drm_output_repaint_atomic(struct weston_output *output_base,
 	}
 
 	/* If there is no current framebuffer, then we need to do a modeset. */
-	if (!output->primary_plane->current) {
+	if ((!output->primary_plane->current) ||
+			(output->ddp_crtc.dirty != CRTC_NO_CHANGED)) {
 		req = drmModeAtomicAlloc();
 		if (!req) {
 			weston_log("DRM: couldn't allocate atomic request\n");
@@ -1709,7 +1891,7 @@ drm_output_repaint(struct weston_output *output_base,
 	mode = container_of(output->base.current_mode, struct drm_mode, base);
 	if (!output->primary_plane->current ||
 	    output->primary_plane->current->strides[0] != output->primary_plane->next->strides[0]) {
-		ret = drmModeSetCrtc(backend->drm.fd, output->crtc_id,
+		ret = drmModeSetCrtc(backend->drm.fd, output->ddp_crtc.crtc_id,
 				     output->primary_plane->next->fb_id, 0, 0,
 				     &output->connector_id, 1,
 				     &mode->mode_info);
@@ -1720,7 +1902,7 @@ drm_output_repaint(struct weston_output *output_base,
 		output_base->set_dpms(output_base, WESTON_DPMS_ON);
 	}
 
-	if (drmModePageFlip(backend->drm.fd, output->crtc_id,
+	if (drmModePageFlip(backend->drm.fd, output->ddp_crtc.crtc_id,
 			    output->primary_plane->next->fb_id,
 			    DRM_MODE_PAGE_FLIP_EVENT, output) < 0) {
 		weston_log("queueing pageflip failed: %m\n");
@@ -1749,7 +1931,7 @@ drm_output_repaint(struct weston_output *output_base,
 			fb_id = s->next->fb_id;
 
 		ret = drmModeSetPlane(backend->drm.fd, s->plane_id,
-				      output->crtc_id, fb_id, flags,
+				      output->ddp_crtc.crtc_id, fb_id, flags,
 				      s->dest_x, s->dest_y,
 				      s->dest_w, s->dest_h,
 				      s->src_x, s->src_y,
@@ -1844,7 +2026,7 @@ drm_output_start_repaint_loop(struct weston_output *output_base)
 			       &output->primary_plane->flip_link);
 
 		drm_plane_update_success(output->primary_plane);
-	} else if (drmModePageFlip(b->drm.fd, output->crtc_id, fb_id,
+	} else if (drmModePageFlip(b->drm.fd, output->ddp_crtc.crtc_id, fb_id,
 				   DRM_MODE_PAGE_FLIP_EVENT, output) < 0) {
 		weston_log("queueing pageflip failed: %m\n");
 		goto finish_frame;
@@ -2001,6 +2183,128 @@ drm_view_transform_supported(struct weston_view *ev)
 		(ev->transform.matrix.type < WESTON_MATRIX_TRANSFORM_ROTATE);
 }
 
+/*
+ * according transform of output, adjust view's transform automatically.
+ * @param mmap_transform: transform to be set to drm
+ * @param out_transform: output's transform
+ * @param ev_transform: view's transform
+*/
+static void
+drm_map_view_transform_to_output(uint32_t *mmap_transform,
+				uint32_t out_transform, uint32_t ev_transform)
+{
+	uint32_t base;
+	int32_t tran, tmp;
+	uint32_t rotate_360 = WL_OUTPUT_TRANSFORM_270 + 1;
+	uint32_t flip_360 = WL_OUTPUT_TRANSFORM_FLIPPED_270 + 1;
+
+	switch(out_transform){
+		case WL_OUTPUT_TRANSFORM_NORMAL:
+			base = WL_OUTPUT_TRANSFORM_NORMAL;
+			break;
+		case WL_OUTPUT_TRANSFORM_90:
+			base = WL_OUTPUT_TRANSFORM_270;
+			break;
+		case WL_OUTPUT_TRANSFORM_180:
+			base = WL_OUTPUT_TRANSFORM_180;
+			break;
+		case WL_OUTPUT_TRANSFORM_270:
+			base = WL_OUTPUT_TRANSFORM_90;
+			break;
+		case WL_OUTPUT_TRANSFORM_FLIPPED:
+			base = WL_OUTPUT_TRANSFORM_FLIPPED;
+			break;
+		case WL_OUTPUT_TRANSFORM_FLIPPED_90:
+			base = WL_OUTPUT_TRANSFORM_FLIPPED_270;
+			break;
+		case WL_OUTPUT_TRANSFORM_FLIPPED_180:
+			base = WL_OUTPUT_TRANSFORM_FLIPPED_180;
+			break;
+		case WL_OUTPUT_TRANSFORM_FLIPPED_270:
+			base = WL_OUTPUT_TRANSFORM_FLIPPED_90;
+			break;
+		default:
+			weston_log("drm_map_view_transform_to_output"
+				"out_transform = %d doesn't support\n",out_transform);
+			base = WL_OUTPUT_TRANSFORM_NORMAL;
+			break;
+	}
+	/*
+	 * consider as two parts: rotate 0 ~ 270 and flip 0 ~ 270.
+	 * according the base calcuted from output_transform to
+	 * determine relations between primary plane and overlay
+	 * plane.
+	*/
+	if (base < rotate_360) {
+		base = rotate_360 - base;
+
+		if (ev_transform < rotate_360){
+			tran = ev_transform - base;
+			if (tran < 0)
+				tran += rotate_360;
+			ev_transform = tran;
+		} else {
+			ev_transform += base;
+			if (ev_transform >= flip_360)
+				ev_transform -= rotate_360;
+		}
+	} else {
+		tmp = rotate_360 - (base & 0b11);
+		base = (base & 0b100) + tmp;
+
+		if (ev_transform >= rotate_360){
+			tran = ev_transform - base;
+			if (tran < 0)
+				tran += rotate_360;
+			ev_transform = tran;
+		} else {
+			ev_transform += base;
+			if (ev_transform >= flip_360)
+				ev_transform -= rotate_360;
+		}
+	}
+	*mmap_transform = ev_transform;
+}
+
+/*
+ * the function is realize the transform of view to match drm driver.
+*/
+static uint32_t
+drm_plane_rotation_get_from_view(uint32_t transform)
+{
+	uint32_t rotate, tran;
+
+	tran = transform & (0b111);
+	switch(tran){
+		case WL_OUTPUT_TRANSFORM_90:
+			rotate = BIT(1);
+			break;
+		case WL_OUTPUT_TRANSFORM_180:
+			rotate = BIT(2);
+			break;
+		case WL_OUTPUT_TRANSFORM_270:
+			rotate = BIT(3);
+			break;
+		case WL_OUTPUT_TRANSFORM_FLIPPED:
+			rotate = BIT(4);
+			break;
+		case WL_OUTPUT_TRANSFORM_FLIPPED_90:
+			rotate = BIT(4) | BIT(1);
+			break;
+		case WL_OUTPUT_TRANSFORM_FLIPPED_180:
+			rotate = BIT(4) | BIT(2);
+			break;
+		case WL_OUTPUT_TRANSFORM_FLIPPED_270:
+			rotate = BIT(4) | BIT(3);
+			break;
+		case WL_OUTPUT_TRANSFORM_NORMAL:
+		default:
+			rotate = BIT(0);
+			break;
+	}
+	return rotate;
+}
+
 static struct weston_plane *
 drm_output_prepare_overlay_view(struct drm_output *output,
 				struct weston_view *ev)
@@ -2015,9 +2319,15 @@ drm_output_prepare_overlay_view(struct drm_output *output,
 	struct gbm_bo *bo;
 	pixman_region32_t dest_rect, src_rect;
 	pixman_box32_t *box, tbox;
-	uint32_t format;
+	uint32_t format, tmpTransform;;
 	wl_fixed_t sx1, sy1, sx2, sy2;
 
+	/*
+	 * if switch controlled by client is off, then return.
+	*/
+	if ((!ev->surface->config_switch)||(!ev->surface->config_switch->sprites_switch))
+		return NULL;
+
 	if (b->gbm == NULL)
 		return NULL;
 
@@ -2169,6 +2479,11 @@ drm_output_prepare_overlay_view(struct drm_output *output,
 	s->src_w = (tbox.x2 - tbox.x1) << 8;
 	s->src_h = (tbox.y2 - tbox.y1) << 8;
 
+	drm_map_view_transform_to_output(&tmpTransform,
+					output->base.transform, viewport->buffer.transform);
+	s->rotation =
+		drm_plane_rotation_get_from_view(tmpTransform);
+
 	if (s->next != s->current)
 		drm_fb_set_buffer(s->next, ev->surface->buffer_ref.buffer);
 
@@ -2311,7 +2626,7 @@ drm_output_set_cursor(struct drm_output *output)
 
 	output->cursor_view = NULL;
 	if (ev == NULL) {
-		drmModeSetCursor(b->drm.fd, output->crtc_id, 0, 0, 0);
+		drmModeSetCursor(b->drm.fd, output->ddp_crtc.crtc_id, 0, 0, 0);
 		output->cursor_plane->plane.x = INT32_MIN;
 		output->cursor_plane->plane.y = INT32_MIN;
 		return;
@@ -2328,7 +2643,7 @@ drm_output_set_cursor(struct drm_output *output)
 
 		cursor_bo_update(b, bo, ev);
 		handle = gbm_bo_get_handle(bo).s32;
-		if (drmModeSetCursor(b->drm.fd, output->crtc_id, handle,
+		if (drmModeSetCursor(b->drm.fd, output->ddp_crtc.crtc_id, handle,
 				b->cursor_width, b->cursor_height)) {
 			weston_log("failed to set cursor: %m\n");
 			b->cursors_are_broken = 1;
@@ -2344,7 +2659,7 @@ drm_output_set_cursor(struct drm_output *output)
 	y = (y - output->base.y) * output->base.current_scale;
 
 	if (output->cursor_plane->plane.x != x || output->cursor_plane->plane.y != y) {
-		if (drmModeMoveCursor(b->drm.fd, output->crtc_id, x, y)) {
+		if (drmModeMoveCursor(b->drm.fd, output->ddp_crtc.crtc_id, x, y)) {
 			weston_log("failed to move cursor: %m\n");
 			b->cursors_are_broken = 1;
 		}
@@ -2495,7 +2810,7 @@ drm_output_destroy(struct weston_output *output_base)
 	struct drm_output *output = (struct drm_output *) output_base;
 	struct drm_backend *b =
 		(struct drm_backend *)output->base.compositor->backend;
-	drmModeCrtcPtr origcrtc = output->original_crtc;
+	drmModeCrtcPtr origcrtc = output->ddp_crtc.original_crtc;
 	int i;
 
 	if (output->page_flip_pending) {
@@ -2511,7 +2826,7 @@ drm_output_destroy(struct weston_output *output_base)
 	output_properties_release(output);
 
 	/* Turn off hardware cursor */
-	drmModeSetCursor(b->drm.fd, output->crtc_id, 0, 0, 0);
+	drmModeSetCursor(b->drm.fd, output->ddp_crtc.crtc_id, 0, 0, 0);
 
 	/* Restore original CRTC state */
 	drmModeSetCrtc(b->drm.fd, origcrtc->crtc_id, origcrtc->buffer_id,
@@ -2519,7 +2834,7 @@ drm_output_destroy(struct weston_output *output_base)
 		       &output->connector_id, 1, &origcrtc->mode);
 	drmModeFreeCrtc(origcrtc);
 
-	b->crtc_allocator &= ~(1 << output->crtc_id);
+	b->crtc_allocator &= ~(1 << output->ddp_crtc.crtc_id);
 	b->connector_allocator &= ~(1 << output->connector_id);
 
 	if (b->use_pixman) {
@@ -3685,13 +4000,13 @@ create_output_for_connector(struct drm_backend *b,
 				     config.seat ? config.seat : "");
 	free(config.seat);
 
-	output->crtc_id = resources->crtcs[i];
+	output->ddp_crtc.crtc_id = resources->crtcs[i];
 	output->pipe = i;
-	b->crtc_allocator |= (1 << output->crtc_id);
+	b->crtc_allocator |= (1 << output->ddp_crtc.crtc_id);
 	output->connector_id = connector->connector_id;
 	b->connector_allocator |= (1 << output->connector_id);
 
-	output->original_crtc = drmModeGetCrtc(b->drm.fd, output->crtc_id);
+	output->ddp_crtc.original_crtc = drmModeGetCrtc(b->drm.fd, output->ddp_crtc.crtc_id);
 	output->dpms_prop = drm_get_prop(b->drm.fd, connector, "DPMS");
 
 	if (connector_get_current_mode(connector, b->drm.fd, &crtc_mode) < 0)
@@ -3705,7 +4020,7 @@ create_output_for_connector(struct drm_backend *b,
 
 	if (mode == WESTON_DRM_BACKEND_OUTPUT_OFF) {
 		weston_log("Disabling output %s\n", output->base.name);
-		drmModeSetCrtc(b->drm.fd, output->crtc_id,
+		drmModeSetCrtc(b->drm.fd, output->ddp_crtc.crtc_id,
 					   0, 0, 0, 0, 0, NULL);
 		goto err_free;
 	}
@@ -3764,12 +4079,14 @@ create_output_for_connector(struct drm_backend *b,
 	else
 		output->base.repaint = drm_output_repaint;
 
+	output->base.set_ddp_prop = drm_set_ddp_prop;
+	output->base.get_ddp_prop = drm_get_ddp_prop;
 	output->base.destroy = drm_output_destroy;
 	output->base.assign_planes = drm_assign_planes;
 	output->base.set_dpms = drm_set_dpms;
 	output->base.switch_mode = drm_output_switch_mode;
 
-	output->base.gamma_size = output->original_crtc->gamma_size;
+	output->base.gamma_size = output->ddp_crtc.original_crtc->gamma_size;
 	output->base.set_gamma = drm_output_set_gamma;
 
 	weston_plane_init(&output->fb_plane, b->compositor, 0, 0);
@@ -3778,7 +4095,8 @@ create_output_for_connector(struct drm_backend *b,
 				      &b->compositor->primary_plane);
 
 	weston_log("Output %s, (connector %d, crtc %d)\n",
-		   output->base.name, output->connector_id, output->crtc_id);
+		   output->base.name, output->connector_id, output->ddp_crtc.crtc_id);
+	config_ddp_prop_global_create(&output->base);
 	wl_list_for_each(m, &output->base.mode_list, link)
 		weston_log_continue(STAMP_SPACE "mode %dx%d@%.1f%s%s%s\n",
 				    m->width, m->height, m->refresh / 1000.0,
@@ -3808,8 +4126,8 @@ err_free:
 		free(drm_mode);
 	}
 
-	drmModeFreeCrtc(output->original_crtc);
-	b->crtc_allocator &= ~(1 << output->crtc_id);
+	drmModeFreeCrtc(output->ddp_crtc.original_crtc);
+	b->crtc_allocator &= ~(1 << output->ddp_crtc.crtc_id);
 	b->connector_allocator &= ~(1 << output->connector_id);
 	free(output);
 	free(config.modeline);
@@ -3906,6 +4224,12 @@ drm_plane_create(struct drm_backend *b, const drmModePlane *kplane)
 		return NULL;
 	}
 
+	plane->rotation = (uint32_t)(plane->props.item[WDRM_PLANE_ROTATE].value);
+	plane->plane_config.alpha = (uint32_t)(plane->props.item[WDRM_PLANE_ALPHA].value);
+	plane->plane_config.colorkey = (uint32_t)(plane->props.item[WDRM_PLANE_COLORKEY].value);
+	plane->plane_config.zpos = (uint32_t)(plane->props.item[WDRM_PLANE_ZPOS].value);
+	plane->plane_config.dirty = PLANE_NO_CHANGED;
+
 	if (b->universal_planes)
 		plane->type = drm_plane_get_type(plane);
 	else
@@ -3965,7 +4289,7 @@ destroy_sprites(struct drm_backend *backend)
 	wl_list_for_each_safe(sprite, next, &backend->plane_list, link) {
 		drmModeSetPlane(backend->drm.fd,
 				sprite->plane_id,
-				output->crtc_id, 0, 0,
+				output->ddp_crtc.crtc_id, 0, 0,
 				0, 0, 0, 0, 0, 0, 0, 0);
 		drm_output_release_fb(output, sprite->current);
 		drm_output_release_fb(output, sprite->next);
@@ -4202,7 +4526,7 @@ drm_backend_set_modes(struct drm_backend *backend)
 		}
 
 		drm_mode = (struct drm_mode *) output->base.current_mode;
-		ret = drmModeSetCrtc(backend->drm.fd, output->crtc_id,
+		ret = drmModeSetCrtc(backend->drm.fd, output->ddp_crtc.crtc_id,
 				     output->primary_plane->current->fb_id, 0, 0,
 				     &output->connector_id, 1,
 				     &drm_mode->mode_info);
@@ -4253,7 +4577,7 @@ session_notify(struct wl_listener *listener, void *data)
 
 		wl_list_for_each(output, &compositor->output_list, base.link) {
 			output->base.repaint_needed = 0;
-			drmModeSetCursor(b->drm.fd, output->crtc_id, 0, 0, 0);
+			drmModeSetCursor(b->drm.fd, output->ddp_crtc.crtc_id, 0, 0, 0);
 		}
 
 		output = container_of(compositor->output_list.next,
@@ -4262,7 +4586,7 @@ session_notify(struct wl_listener *listener, void *data)
 		wl_list_for_each(sprite, &b->plane_list, link)
 			drmModeSetPlane(b->drm.fd,
 					sprite->plane_id,
-					output->crtc_id, 0, 0,
+					output->ddp_crtc.crtc_id, 0, 0,
 					0, 0, 0, 0, 0, 0, 0, 0);
 	};
 }
diff --git a/src/compositor.h b/src/compositor.h
index 2507b79..99b2fe4 100644
--- a/src/compositor.h
+++ b/src/compositor.h
@@ -45,6 +45,8 @@ extern "C" {
 #include "zalloc.h"
 #include "timeline-object.h"
 
+#define BIT(nr)		(1UL << (nr))
+
 struct weston_transform {
 	struct weston_matrix matrix;
 	struct wl_list link;
@@ -166,6 +168,59 @@ enum dpms_enum {
 	WESTON_DPMS_OFF
 };
 
+/**
+ * Possible values for the DRM_PLANE_TYPE property.
+ */
+enum backend_plane_type {
+	BACKEND_PLANE_TYPE_PRIMARY = 0,
+	BACKEND_PLANE_TYPE_CURSOR,
+	BACKEND_PLANE_TYPE_OVERLAY,
+	BACKEND_PLANE_TYPE__COUNT
+};
+
+/**
+ * state which property changed.
+ */
+enum plane_prop_changed {
+	PLANE_NO_CHANGED = BIT(0),
+	PLANE_ALPHA_CHANGED = BIT(1),
+	PLANE_COLORKEY_CHANGED = BIT(2),
+	PLANE_ZPOS_CHANGED = BIT(3),
+};
+
+/**
+ * state which property changed.
+ */
+enum crtc_prop_changed {
+	CRTC_NO_CHANGED = BIT(0),
+	CRTC_BACKGROUND_CHANGED = BIT(1),
+};
+
+struct plane_base_prop{
+	struct wl_list link;
+	uint32_t alpha;
+	uint32_t colorkey;
+	uint32_t zpos;
+	uint32_t plane_id;
+	uint32_t crtc_id;
+	enum backend_plane_type type;
+	enum plane_prop_changed dirty;
+};
+
+/*drm data path properties, one crtc match multi-plane*/
+struct ddp_prop{
+	struct wl_list ddp_res_list;
+	struct wl_global *global;
+	void *private;
+
+	uint32_t crtc_id;
+	int32_t crtc_background;
+	enum crtc_prop_changed crtc_dirty;
+
+	uint32_t num_plane;
+	struct wl_list plane_list;
+};
+
 struct weston_output {
 	uint32_t id;
 	char *name;
@@ -176,6 +231,7 @@ struct weston_output {
 	struct wl_list resource_list;
 	struct wl_global *global;
 	struct weston_compositor *compositor;
+	struct ddp_prop *ddp;
 
 	/** From global to output buffer coordinates. */
 	struct weston_matrix matrix;
@@ -219,6 +275,10 @@ struct weston_output {
 	void (*start_repaint_loop)(struct weston_output *output);
 	int (*repaint)(struct weston_output *output,
 			pixman_region32_t *damage);
+	int (*set_ddp_prop)(struct weston_output *output_base,
+			struct ddp_prop *ddp);
+	int (*get_ddp_prop)(struct weston_output *output_base,
+			struct ddp_prop *ddp);
 	void (*destroy)(struct weston_output *output);
 	void (*assign_planes)(struct weston_output *output);
 	int (*switch_mode)(struct weston_output *output, struct weston_mode *mode);
@@ -1001,6 +1061,16 @@ struct weston_surface_state {
 	struct weston_buffer_viewport buffer_viewport;
 };
 
+/*
+ * For setting whether the views on this surface walk
+ * overlay path; on==>1, off==>0
+*/
+struct config_switch{
+	struct wl_resource *resource;
+	void *private;
+	int sprites_switch;
+};
+
 struct weston_surface {
 	struct wl_resource *resource;
 	struct wl_signal destroy_signal; /* callback argument: this surface */
@@ -1085,6 +1155,8 @@ struct weston_surface {
 	const char *role_name;
 
 	struct weston_timeline_object timeline;
+
+	struct config_switch *config_switch;
 };
 
 struct weston_subsurface {
diff --git a/src/main.c b/src/main.c
index 09905ea..280e54a 100644
--- a/src/main.c
+++ b/src/main.c
@@ -48,6 +48,7 @@
 #include "../shared/helpers.h"
 #include "git-version.h"
 #include "version.h"
+#include "weston-configure-mtk.h"
 
 #include "compositor-drm.h"
 #include "compositor-headless.h"
@@ -1383,6 +1384,11 @@ int main(int argc, char *argv[])
 		goto out;
 	}
 
+	if (config_switch_global_create(ec) < 0) {
+		weston_log("fatal: failed to config_switch_global_create\n");
+		goto out;
+	}
+
 	catch_signals();
 	segv_compositor = ec;
 
diff --git a/src/weston-configure-mtk.c b/src/weston-configure-mtk.c
new file mode 100644
index 0000000..3f6509e
--- /dev/null
+++ b/src/weston-configure-mtk.c
@@ -0,0 +1,413 @@
+#include "config.h"
+#include <fcntl.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <limits.h>
+#include <stdarg.h>
+#include <assert.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/wait.h>
+#include <sys/socket.h>
+#include <sys/utsname.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <math.h>
+#include <linux/input.h>
+#include <dlfcn.h>
+#include <signal.h>
+#include <setjmp.h>
+#include <sys/time.h>
+#include <time.h>
+#include <errno.h>
+
+#include "timeline.h"
+
+#include "compositor.h"
+#include "scaler-server-protocol.h"
+#include "shared/helpers.h"
+#include "shared/os-compatibility.h"
+#include "shared/timespec-util.h"
+#include "git-version.h"
+#include "version.h"
+
+#include "weston-configure-mtk.h"
+#include "weston-configure-mtk-server-protocol.h"
+
+static void
+config_drm_set_crtc_background(struct wl_client *client, struct wl_resource *resource,
+					uint32_t crtc_id, int32_t background)
+{
+	struct ddp_prop *ddp = wl_resource_get_user_data(resource);
+	struct weston_output *output = (struct weston_output *)ddp->private;
+	struct wl_resource *tmpresource;
+	int ret;
+
+	if (crtc_id != ddp->crtc_id)
+		return;
+
+	if (background < 0)
+		return;
+
+	ddp->crtc_background = background;
+	ddp->crtc_dirty |= CRTC_BACKGROUND_CHANGED;
+	ret = output->set_ddp_prop(output, ddp);
+	if (ret < 0) {
+		weston_log("error: fail to set_plane_prop\n");
+		return;
+	}
+	/* send drm crtc properties to client which notice it*/
+	wl_resource_for_each(tmpresource, &ddp->ddp_res_list) {
+		config_ddp_prop_send_crtc_param(tmpresource,
+					ddp->crtc_background, ddp->crtc_id);
+	}
+}
+
+static void
+config_drm_set_plane_alpha(struct wl_client *client, struct wl_resource *resource,
+					uint32_t crtc_id, struct wl_array *alpha)
+{
+	struct ddp_prop *ddp = wl_resource_get_user_data(resource);
+	struct weston_output *output = (struct weston_output *)ddp->private;
+	struct wl_resource *tmpresource;
+	struct plane_base_prop *posplane, *tmplane;
+	uint32_t plane_id = 0;
+	uint32_t alpha_u32;
+	uint64_t *p64, alpha_u64;
+	int ret;
+
+	if (crtc_id != ddp->crtc_id)
+		return;
+
+	wl_array_for_each(p64, alpha) {
+		/*bit0~bit32: prop value; bit33~bit63: plane_id*/
+		plane_id = (uint32_t)(((*p64) & (0xfffffffe00000000)) >> 33);
+		alpha_u64 = (uint64_t)((*p64) & (0x00000001ffffffff));
+		if (!plane_id) {
+			weston_log("error: the parameters set alpha operation is invalid\n");
+			return;
+		}
+		/*BIT32 is a sign bit, 0 stand positive, 1 stand negative*/
+		if ((alpha_u64 >> 32) == 1)
+			continue;
+
+		alpha_u32 = (uint32_t)alpha_u64;
+		wl_list_for_each_safe(posplane, tmplane, &ddp->plane_list, link) {
+			if (posplane->plane_id == plane_id)
+			{
+				posplane->dirty |= PLANE_ALPHA_CHANGED;
+				posplane->alpha = alpha_u32;
+				break;
+			}
+		}
+	}
+
+	ret = output->set_ddp_prop(output, ddp);
+	if (ret < 0) {
+		weston_log("error: fail to set_plane_prop\n");
+		return;
+	}
+	/* send drm plane properties to client which notice it*/
+	wl_resource_for_each(tmpresource, &ddp->ddp_res_list) {
+		wl_list_for_each_safe(posplane, tmplane, &ddp->plane_list, link) {
+			config_ddp_prop_send_plane_param(tmpresource,
+					posplane->crtc_id, posplane->alpha,
+					posplane->colorkey, posplane->zpos,
+					posplane->plane_id, posplane->type);
+		}
+	}
+}
+
+static void
+config_drm_set_plane_colorkey(struct wl_client *client,struct wl_resource *resource,
+						uint32_t crtc_id, struct wl_array *colorkey)
+{
+	struct ddp_prop *ddp = wl_resource_get_user_data(resource);
+	struct weston_output *output = (struct weston_output *)ddp->private;
+	struct wl_resource *tmpresource;
+	struct plane_base_prop *posplane, *tmplane;
+	uint32_t plane_id = 0;
+	uint32_t colorkey_u32;
+	uint64_t *p64, colorkey_u64;
+	int ret;
+
+	if (crtc_id != ddp->crtc_id)
+		return;
+
+	wl_array_for_each(p64, colorkey) {
+		/*bit0~bit32: prop value; bit33~bit63: plane_id*/
+		plane_id = (uint32_t)(((*p64) & (0xfffffffe00000000)) >> 33);
+		colorkey_u64 = (uint64_t)((*p64) & (0x00000001ffffffff));
+		if (!plane_id) {
+			weston_log("error: the parameters set colorkey operation is invalid\n");
+			return;
+		}
+		/*BIT32 is a sign bit, 0 stand positive, 1 stand negative*/
+		if ((colorkey_u64 >> 32) == 1)
+			continue;
+
+		colorkey_u32 = (uint32_t)colorkey_u64;
+		wl_list_for_each_safe(posplane, tmplane, &ddp->plane_list, link) {
+			if (posplane->plane_id == plane_id)
+			{
+				posplane->dirty |= PLANE_COLORKEY_CHANGED;
+				posplane->colorkey = colorkey_u32;
+				break;
+			}
+		}
+	}
+
+	ret = output->set_ddp_prop(output, ddp);
+	if (ret < 0) {
+		weston_log("error: fail to set_plane_prop\n");
+		return;
+	}
+	/* send drm plane properties to client which notice it*/
+	wl_resource_for_each(tmpresource, &ddp->ddp_res_list) {
+		wl_list_for_each_safe(posplane, tmplane, &ddp->plane_list, link) {
+			config_ddp_prop_send_plane_param(tmpresource,
+					posplane->crtc_id, posplane->alpha,
+					posplane->colorkey, posplane->zpos,
+					posplane->plane_id, posplane->type);
+		}
+	}
+}
+
+static void
+config_drm_set_plane_zpos(struct wl_client *client, struct wl_resource *resource,
+						uint32_t crtc_id, struct wl_array *zpos)
+{
+	struct ddp_prop *ddp = wl_resource_get_user_data(resource);
+	struct weston_output *output = (struct weston_output *)ddp->private;
+	struct wl_resource *tmpresource;
+	struct plane_base_prop *posplane, *tmplane;
+	uint32_t plane_id = 0;
+	uint32_t zpos_u32;
+	uint64_t *p64, zpos_u64;
+	int ret;
+
+	if (crtc_id != ddp->crtc_id)
+		return;
+
+	wl_array_for_each(p64, zpos) {
+		/*bit0~bit32: prop value; bit33~bit63: plane_id*/
+		plane_id = (uint32_t)(((*p64) & (0xfffffffe00000000)) >> 33);
+		zpos_u64 = (uint64_t)((*p64) & (0x00000001ffffffff));
+		if (!plane_id) {
+			weston_log("error: the parameters set alpha operation is invalid\n");
+			return;
+		}
+		/*BIT32 is a sign bit, 0 stand positive, 1 stand negative*/
+		if ((zpos_u64 >> 32) == 1)
+			continue;
+
+		zpos_u32 = (uint32_t)zpos_u64;
+		wl_list_for_each_safe(posplane, tmplane, &ddp->plane_list, link) {
+			if (posplane->plane_id == plane_id)
+			{
+				posplane->dirty |= PLANE_ZPOS_CHANGED;
+				posplane->zpos = zpos_u32;
+				break;
+			}
+		}
+	}
+
+	ret = output->set_ddp_prop(output, ddp);
+	if (ret < 0) {
+		weston_log("error: fail to set_plane_prop\n");
+		return;
+	}
+	/* send drm plane properties to client which notice it*/
+	wl_resource_for_each(tmpresource, &ddp->ddp_res_list) {
+		wl_list_for_each_safe(posplane, tmplane, &ddp->plane_list, link) {
+			config_ddp_prop_send_plane_param(tmpresource,
+					posplane->crtc_id, posplane->alpha,
+					posplane->colorkey, posplane->zpos,
+					posplane->plane_id, posplane->type);
+		}
+	}
+}
+
+
+static const struct config_ddp_prop_interface config_ddp_set_interface = {
+	config_drm_set_plane_zpos,
+	config_drm_set_plane_colorkey,
+	config_drm_set_plane_alpha,
+	config_drm_set_crtc_background
+};
+
+static void
+ddp_prop_destroy(struct wl_resource *resource)
+{
+	wl_list_remove(wl_resource_get_link(resource));
+}
+
+static void
+bind_config_drm_data_path(struct wl_client *client,
+		void *data, uint32_t version, uint32_t id)
+{
+	struct ddp_prop *ddp = (struct ddp_prop *)data;
+	struct wl_resource *resource;
+	struct plane_base_prop *posplane, *tmplane;
+
+	resource = wl_resource_create(client, &config_ddp_prop_interface,
+				      MIN(version, 1), id);
+	if (resource == NULL) {
+		wl_client_post_no_memory(client);
+		return;
+	}
+	wl_list_insert(&ddp->ddp_res_list, wl_resource_get_link(resource));
+
+	wl_resource_set_implementation(resource, &config_ddp_set_interface,
+				       data, ddp_prop_destroy);
+
+	config_ddp_prop_send_crtc_param(resource,
+				ddp->crtc_background, ddp->crtc_id);
+	/*send plane's properties to the client*/
+	wl_list_for_each_safe(posplane, tmplane, &ddp->plane_list, link) {
+		config_ddp_prop_send_plane_param(resource,
+				posplane->crtc_id, posplane->alpha,
+				posplane->colorkey, posplane->zpos,
+				posplane->plane_id, posplane->type);
+	}
+}
+
+WL_EXPORT void
+config_ddp_prop_global_destroy(struct weston_output *o)
+{
+	struct ddp_prop *ddp = o->ddp;
+	struct wl_resource *resource;
+	wl_resource_for_each(resource, &ddp->ddp_res_list) {
+		wl_resource_set_destructor(resource, NULL);
+	}
+	wl_global_destroy(ddp->global);
+
+	if (ddp)
+		free(ddp);
+}
+
+WL_EXPORT int
+config_ddp_prop_global_create(struct weston_output *o)
+{
+	struct ddp_prop *ddp;
+	int32_t ret;
+
+	if(!o)
+		return -1;
+
+	ddp = (struct ddp_prop *)malloc(sizeof(*ddp));
+	if(ddp == NULL)
+		return -1;
+
+	wl_list_init(&ddp->ddp_res_list);
+	wl_list_init(&ddp->plane_list);
+	ddp->private = (void *)o;
+	o->ddp = ddp;
+
+	ddp->global = wl_global_create(o->compositor->wl_display,
+					&config_ddp_prop_interface, 1, ddp, bind_config_drm_data_path);
+	if (ddp->global == NULL){
+		fprintf(stderr, "error: failed to config_ddp_prop_global_create: %s\n", dlerror());
+		return -1;
+	}
+	if(o->get_ddp_prop) {
+		ret = o->get_ddp_prop(o, ddp);
+		if (ret < 0) {
+			weston_log("error: fail to get plane prop\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static void
+config_set_sprite_switch(struct wl_client *client,
+	       struct wl_resource *resource,
+	       int32_t spr_switch)
+{
+	struct config_switch *configure = wl_resource_get_user_data(resource);
+
+	configure->sprites_switch = spr_switch;
+}
+
+static const struct config_switch_set_interface switch_set_interface = {
+	config_set_sprite_switch,
+};
+
+static struct config_switch *
+config_interface_create(struct weston_surface *surface)
+{
+	struct config_switch *config_switch;
+
+	config_switch = zalloc(sizeof *config_switch);
+	if (config_switch == NULL)
+		return NULL;
+
+	config_switch->private = (void *)surface;
+	surface->config_switch = config_switch;
+
+	return config_switch;
+}
+
+static void
+config_switch_connect(struct wl_client *client, struct wl_resource *resource,
+	struct wl_resource *wl_surface, uint32_t id)
+{
+	struct config_switch *config_switch = wl_resource_get_user_data(resource);
+	struct weston_surface *surface = wl_resource_get_user_data(wl_surface);
+
+	config_switch = config_interface_create(surface);
+	if (config_switch == NULL) {
+		wl_resource_post_no_memory(resource);
+		return;
+	}
+
+	config_switch->resource =
+		wl_resource_create(client, &config_switch_set_interface,
+				   wl_resource_get_version(resource), id);
+	if (config_switch->resource == NULL) {
+		wl_resource_post_no_memory(resource);
+		return;
+	}
+	wl_resource_set_implementation(config_switch->resource, &switch_set_interface,
+				       config_switch, NULL);
+}
+
+static const struct config_switch_interface switch_interface = {
+	config_switch_connect,
+};
+
+static void
+bind_config_switch(struct wl_client *client,
+		void *data, uint32_t version, uint32_t id)
+{
+	struct weston_compositor *compositor = data;
+	struct wl_resource *resource;
+
+	resource = wl_resource_create(client, &config_switch_interface,
+				      MIN(version, 1), id);
+	if (resource == NULL) {
+		wl_client_post_no_memory(client);
+		return;
+	}
+
+	wl_resource_set_implementation(resource, &switch_interface,
+				       compositor, NULL);
+}
+
+WL_EXPORT int
+config_switch_global_create(struct weston_compositor *ec)
+{
+	if(!ec)
+		return -1;
+	if (!wl_global_create(ec->wl_display, &config_switch_interface, 1,
+			  ec, bind_config_switch)){
+		fprintf(stderr, "error: failed to config_switch_global_create: %s\n", dlerror());
+		return -1;
+	}
+	return 0;
+}
+
diff --git a/src/weston-configure-mtk.h b/src/weston-configure-mtk.h
new file mode 100644
index 0000000..7b80e65
--- /dev/null
+++ b/src/weston-configure-mtk.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright © 2008-2011 Kristian Høgsberg
+ * Copyright © 2012 Collabora, Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef _APP_CONFIGURE_EXTENSION_H_
+#define _APP_CONFIGURE_EXTENSION_H_
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#include <stdbool.h>
+#include <time.h>
+#include <pixman.h>
+#include <xkbcommon/xkbcommon.h>
+
+#include <wayland-server.h>
+
+#include "version.h"
+#include "matrix.h"
+#include "config-parser.h"
+#include "zalloc.h"
+#include "timeline-object.h"
+
+int config_switch_global_create(struct weston_compositor *ec);
+int config_ddp_prop_global_create(struct weston_output *o);
+void config_ddp_prop_global_destroy(struct weston_output *o);
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
+
-- 
1.9.1

