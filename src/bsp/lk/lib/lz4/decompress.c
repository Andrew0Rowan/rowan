/*
 * LZ4 - Fast LZ compression algorithm
 * Copyright (C) 2011-2012, Yann Collet.
 * BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * You can contact the author at :
 * - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
 * - LZ4 source repository : http://code.google.com/p/lz4/
 *
 *  Changed for kernel use by:
 *  Chanho Min <chanho.min@lge.com>
 */
/*
 * Copyright (c) 2016 MediaTek Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <debug.h>
#include <string.h>
#include <sys/types.h>
#include <lib/decompress.h>

#define BYTE u8
#define __force
#define __bitwise

#define ML_BITS  4
#define COPYLENGTH 8
#define RUN_BITS (8 - ML_BITS)
#define RUN_MASK ((1U << RUN_BITS) - 1)
#define ML_MASK  ((1U << ML_BITS) - 1)

/*
 * Note: Uncompressed chunk size is used in the compressor side
 * (userspace side for compression).
 * It is hardcoded because there is not proper way to extract it
 * from the binary stream which is generated by the preliminary
 * version of LZ4 tool so far.
 */
#define ARCHIVE_MAGICNUMBER 0x184C2102
#define LZ4_DEFAULT_UNCOMPRESSED_CHUNK_SIZE (8 << 20)

#define unlikely(x) __builtin_expect(!!(x), 0)

static const int dec32table[] = {0, 3, 2, 3, 0, 0, 0, 0};
#if LZ4_ARCH64
static const int dec64table[] = {0, 0, 0, -1, 0, 1, 2, 3};
#endif

typedef unsigned int __u32;
typedef unsigned short __u16;
typedef __u16 __bitwise __le16;
typedef __u32 __bitwise __le32;

typedef struct _U16_S { u16 v; } U16_S;
typedef struct _U32_S { u32 v; } U32_S;
typedef struct _U64_S { u64 v; } U64_S;

#define le16_to_cpup __le16_to_cpup
#define le32_to_cpup __le32_to_cpup

#define A16(x) (((U16_S *)(x))->v)
#define A32(x) (((U32_S *)(x))->v)
#define A64(x) (((U64_S *)(x))->v)

#define PUT4(s, d) (A32(d) = A32(s))
#define PUT8(s, d) (A64(d) = A64(s))

#define LZ4_READ_LITTLEENDIAN_16(d, s, p) \
        (d = s - get_unaligned_le16(p))

#define LZ4_WILDCOPY(s, d, e)       \
        do {                        \
            LZ4_COPYPACKET(s, d);   \
        } while (d < e)

#if LZ4_ARCH64 /* 64-bit */
#define STEPSIZE 8

#define LZ4_COPYSTEP(s, d)  \
    do {            \
        PUT8(s, d); \
        d += 8;     \
        s += 8;     \
    } while (0)

#define LZ4_COPYPACKET(s, d)    LZ4_COPYSTEP(s, d)

#define LZ4_SECURECOPY(s, d, e)         \
    do {                    \
        if (d < e) {            \
            LZ4_WILDCOPY(s, d, e);  \
        }               \
    } while (0)

#else   /* 32-bit */
#define STEPSIZE 4

#define LZ4_COPYSTEP(s, d)  \
    do {            \
        PUT4(s, d); \
        d += 4;     \
        s += 4;     \
    } while (0)

#define LZ4_COPYPACKET(s, d)        \
    do {                \
        LZ4_COPYSTEP(s, d); \
        LZ4_COPYSTEP(s, d); \
    } while (0)

#define LZ4_SECURECOPY  LZ4_WILDCOPY

#endif

static inline __u16 __le16_to_cpup(const __le16 *p)
{
    return (__force __u16)*p;
}

static inline u16 get_unaligned_le16(const void *p)
{
    return le16_to_cpup((__le16 *)p);
}

static inline __u32 __le32_to_cpup(const __le32 *p)
{
    return (__force __u32)*p;
}

static inline u32 get_unaligned_le32(const void *p)
{
    return le32_to_cpup((__le32 *)p);
}

static int lz4_uncompress(const char *source, char *dest, int osize)
{
    const BYTE *ip = (const BYTE *) source;
    const BYTE *ref;
    BYTE *op = (BYTE *) dest;
    BYTE *const oend = op + osize;
    BYTE *cpy;
    unsigned int token;
    size_t length;

    while (1) {

        /* get runlength */
        token = *ip++;
        length = (token >> ML_BITS);
        if (length == RUN_MASK) {
            size_t len;

            len = *ip++;
            for (; len == 255; length += 255)
                len = *ip++;
            if (unlikely(length > (size_t)(length + len))) {
                goto _output_error;
            }
            length += len;
        }

        /* copy literals */
        cpy = op + length;
        if (unlikely(cpy > oend - COPYLENGTH)) {
            /*
             * Error: not enough place for another match
             * (min 4) + 5 literals
             */
            if (cpy != oend) {
                goto _output_error;
            }

            memcpy(op, ip, length);
            ip += length;
            break; /* EOF */
        }
        LZ4_WILDCOPY(ip, op, cpy);
        ip -= (op - cpy);
        op = cpy;

        /* get offset */
        LZ4_READ_LITTLEENDIAN_16(ref, cpy, ip);
        ip += 2;

        /* Error: offset create reference outside destination buffer */
        if (unlikely(ref < (BYTE *const) dest)) {
            goto _output_error;
        }

        /* get matchlength */
        length = token & ML_MASK;
        if (length == ML_MASK) {
            for (; *ip == 255; length += 255)
                ip++;
            if (unlikely(length > (size_t)(length + *ip))) {
                goto _output_error;
            }
            length += *ip++;
        }

        /* copy repeated sequence */
        if (unlikely((op - ref) < STEPSIZE)) {
#if LZ4_ARCH64
            int dec64 = dec64table[op - ref];
#else
            const int dec64 = 0;
#endif
            op[0] = ref[0];
            op[1] = ref[1];
            op[2] = ref[2];
            op[3] = ref[3];
            op += 4;
            ref += 4;
            ref -= dec32table[op-ref];
            PUT4(ref, op);
            op += STEPSIZE - 4;
            ref -= dec64;
        } else {
            LZ4_COPYSTEP(ref, op);
        }
        cpy = op + length - (STEPSIZE - 4);
        if (cpy > (oend - COPYLENGTH)) {

            /* Error: request to write beyond destination buffer */
            if (cpy > oend) {
                goto _output_error;
            }
#if LZ4_ARCH64
            if ((ref + COPYLENGTH) > oend)
#else
            if ((ref + COPYLENGTH) > oend ||
                    (op + COPYLENGTH) > oend) {
#endif
                goto _output_error;
            }
            LZ4_SECURECOPY(ref, op, (oend - COPYLENGTH));
            while (op < cpy)
                *op++ = *ref++;
            op = cpy;
            /*
             * Check EOF (should never happen, since last 5 bytes
             * are supposed to be literals)
             */
            if (op == oend) {
                goto _output_error;
            }
            continue;
        }
        LZ4_SECURECOPY(ref, op, cpy);
        op = cpy; /* correction */
    }

    /* end of decoding */
    return (int) (((char *)ip) - source);

    /* write overflow error detected */
_output_error:
    return -ELZ4WO;
}

static int lz4_decompress(const char *src, size_t *src_len,
                          char *dest, size_t actual_dest_len)
{
    int input_len = 0;

    input_len = lz4_uncompress(src, dest, actual_dest_len);

    if (input_len < 0)
        return -ELZ4IR;

    /* decode successfully */
    *src_len = input_len;

    return LZ4_OK;
}

int unlz4(const void *input, int in_len, void *output)
{
    int ret = -1;
    u8 *inp, *outp, *inp_start;
    size_t chunksize = 0, dest_len;
    size_t uncomp_chunksize = LZ4_DEFAULT_UNCOMPRESSED_CHUNK_SIZE;
    size_t out_len = get_unaligned_le32(input + in_len);
    long size = in_len;

    if (output) {
        outp = output;
    } else {
        dprintf(ALWAYS, "unlz4 error: NULL output pointer\n");
        return -ELZ4NP;
    }

    if (input) {
        inp = input;
    } else {
        dprintf(ALWAYS, "unlz4 error: NULL input pointer\n");
        return -ELZ4NP;
    }
    inp_start = inp;

    chunksize = get_unaligned_le32(inp);
    if (chunksize == ARCHIVE_MAGICNUMBER) {
        inp += 4;
        size -= 4;
    } else {
        dprintf(ALWAYS, "unlz4 error: invalid header\n");
        return -ELZ4IH;
    }

    for (;;) {

        chunksize = get_unaligned_le32(inp);
        if (chunksize == ARCHIVE_MAGICNUMBER) {
            inp += 4;
            size -= 4;
            continue;
        }

        inp += 4;
        size -= 4;

        if (out_len >= uncomp_chunksize) {
            dest_len = uncomp_chunksize;
            out_len -= dest_len;
        } else {
            dest_len = out_len;
        }

        ret = lz4_decompress(inp, &chunksize, outp, dest_len);
        if (ret < 0) {
            dprintf(ALWAYS, "unlz4 error: decodes failure\n");
            return -ELZ4DF;
        }

        if (output)
            outp += dest_len;

        size -= chunksize;

        if (size == 0) // Note: here should append size info at the end
            break;
        else if (size < 0) {
            dprintf(ALWAYS, "unlz4 error: data corrupt\n");
            return -ELZ4DC;
        }

        inp += chunksize;
    }

    return LZ4_OK;
}
